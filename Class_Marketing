import os
import json
import numpy as np
import pandas as pd
from typing import Dict, Any, Optional, List, Union, Tuple
from datetime import datetime
from dataclasses import dataclass
import logging

# ============================================================================
# çµ±ä¸€ã•ã‚ŒãŸå®šæ•°å®šç¾© (ä¿®æ­£å®Œäº†)
# ============================================================================

class MarketConstants:
    """å¸‚å ´é–¢é€£ã®å®šæ•°ã‚’ä¸€å…ƒç®¡ç†"""
    DEFAULT_SP500_PRICE = 5900.0
    VIX_DEFAULT = 20.0
    RSI_OVERSOLD = 30
    RSI_OVERBOUGHT = 70
    MAX_CONFIDENCE = 0.99  # ä¿¡é ¼åº¦ä¸Šé™ã‚’æ˜ç¢ºã«å®šç¾©
    MIN_CONFIDENCE = 0.01  # ä¿¡é ¼åº¦ä¸‹é™ã‚’æ˜ç¢ºã«å®šç¾©

class ProfileConstants:
    """ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šã®çµ±ä¸€å®šç¾©"""
    UNIFIED_PROFILES = {
        "natural": {
            "buy_threshold": 2, "sell_threshold": 2, "vix_threshold": 25,
            "confidence_threshold": 0.6, "ai_weight": 2.0,
            "short_trend_threshold_pct": 0.5, "error_accept_threshold_pct": 8.0,
            "profile_description": "æ¨™æº–çš„ãªãƒãƒ©ãƒ³ã‚¹å‹ã€‚åŸºæœ¬é–¾å€¤ã§ã‚·ã‚°ãƒŠãƒ«åˆ¤å®šã€‚"
        },
        "aggressive": {
            "buy_threshold": 1, "sell_threshold": 3, "vix_threshold": 30,
            "confidence_threshold": 0.4, "ai_weight": 1.5,
            "short_trend_threshold_pct": 0.2, "error_accept_threshold_pct": 10.0,
            "profile_description": "ç©æ¥µå‹ã€‚è²·ã„é–¾å€¤ä½ã‚ã€VIXè¨±å®¹é«˜ã‚ã€‚"
        },
        "conservative": {
            "buy_threshold": 3, "sell_threshold": 1, "vix_threshold": 20,
            "confidence_threshold": 0.8, "ai_weight": 3.0,
            "short_trend_threshold_pct": 1.0, "error_accept_threshold_pct": 6.0,
            "profile_description": "æ…é‡å‹ã€‚è²·ã„é–¾å€¤é«˜ã‚ã€VIXè¨±å®¹ä½ã‚ã€‚"
        }
    }

# ============================================================================
# ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹å®šç¾© (å‹å®‰å…¨æ€§ç¢ºä¿)
# ============================================================================

@dataclass
class PredictionResult:
    """AIäºˆæ¸¬çµæœã®çµ±ä¸€ãƒ‡ãƒ¼ã‚¿æ§‹é€ """
    trend_pct: float
    confidence: float
    price: float
    model_type: str
    mape: float = 0.0
    
    def __post_init__(self):
        """ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ã‚’ä¿è¨¼"""
        # ä¿¡é ¼åº¦ã®ç¯„å›²åˆ¶é™ (é‡è¦ä¿®æ­£)
        self.confidence = max(MarketConstants.MIN_CONFIDENCE, 
                            min(MarketConstants.MAX_CONFIDENCE, self.confidence))
        
        # ä¾¡æ ¼ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        if self.price <= 0 or self.price > 50000:
            raise ValueError(f"ç•°å¸¸ãªäºˆæ¸¬ä¾¡æ ¼: {self.price}")
        
        # å°æ•°ç‚¹2æ¡ã«çµ±ä¸€
        self.price = round(self.price, 2)
        self.trend_pct = round(self.trend_pct, 2)

@dataclass
class MarketStatus:
    """å¸‚å ´çŠ¶æ³ã®çµ±ä¸€ãƒ‡ãƒ¼ã‚¿æ§‹é€ """
    current_price: float
    last_price_date: str
    daily_change: float
    volatility_5d: float
    vix: float
    vix_level: str
    volume: float = 0.0

@dataclass
class TechnicalSignals:
    """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æçµæœã®çµ±ä¸€ãƒ‡ãƒ¼ã‚¿æ§‹é€ """
    total_buy_score: int
    total_sell_score: int
    ma_cross_status: str
    rsi_signal: str
    rsi_current: float = 50.0
    recent_days_for_count: int = 15

@dataclass
class MarketAssessment:
    """å¸‚å ´è©•ä¾¡ã®ç·åˆçµæœ"""
    trend: str
    confidence: float
    risk_level: str
    tech_score: float
    ai_reliability: float
    
    def __post_init__(self):
        """ä¿¡é ¼åº¦ã®ç¯„å›²åˆ¶é™ (é‡è¦ä¿®æ­£)"""
        self.confidence = max(0.1, min(0.9, self.confidence))
        self.ai_reliability = max(0.1, min(0.9, self.ai_reliability))
        self.tech_score = max(0.0, min(1.0, self.tech_score))

# ============================================================================
# ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
# ============================================================================

class ValidationError(Exception):
    """ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã‚¨ãƒ©ãƒ¼"""
    pass

class ConfidenceCalculator:
    """ä¿¡é ¼åº¦è¨ˆç®—ã®çµ±ä¸€åŒ–"""
    
    @staticmethod
    def calculate_confidence(mape: float) -> float:
        """MAPEå€¤ã‹ã‚‰ä¿¡é ¼åº¦ã‚’è¨ˆç®—ï¼ˆç¯„å›²åˆ¶é™ä»˜ãï¼‰"""
        if mape is None or mape < 0:
            return 0.5
        
        # MAPE-based confidence with hard limits
        confidence = (100 - mape) / 100
        
        # å¼·åˆ¶çš„ã«ç¯„å›²åˆ¶é™ (é‡è¦ä¿®æ­£)
        confidence = max(MarketConstants.MIN_CONFIDENCE, 
                        min(MarketConstants.MAX_CONFIDENCE, confidence))
        
        return confidence

class PriceValidator:
    """ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§æ¤œè¨¼"""
    
    @staticmethod
    def validate_prediction_price(raw_price: Any, model_type: str) -> float:
        """äºˆæ¸¬ä¾¡æ ¼ã®å¦¥å½“æ€§ã‚’ä¿è¨¼"""
        try:
            if isinstance(raw_price, (list, np.ndarray)):
                if len(raw_price) == 0:
                    raise ValueError("ç©ºã®äºˆæ¸¬é…åˆ—")
                price = float(raw_price[-1])  # å¸¸ã«æœ€å¾Œã®å€¤
            else:
                price = float(raw_price)
                
            # ç¯„å›²ãƒã‚§ãƒƒã‚¯
            if price <= 0 or price > 50000:
                raise ValueError(f"ç•°å¸¸ãªäºˆæ¸¬ä¾¡æ ¼: {price}")
                
            # å°æ•°ç‚¹2æ¡ã§çµ±ä¸€
            return round(price, 2)
            
        except Exception as e:
            logging.error(f"{model_type}äºˆæ¸¬ä¾¡æ ¼æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return MarketConstants.DEFAULT_SP500_PRICE

class TrendJudge:
    """ãƒˆãƒ¬ãƒ³ãƒ‰åˆ¤å®šã®çµ±ä¸€åŒ–"""
    
    @staticmethod
    def judge_overall_trend(ai_predictions: Dict[str, PredictionResult], 
                          technical_signals: TechnicalSignals) -> str:
        """AIäºˆæ¸¬ã¨ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã®çµ±åˆåˆ¤å®š"""
        
        # AIäºˆæ¸¬ã®é‡ã¿ä»˜ã‘å¹³å‡
        ai_trends = []
        weights = {'nextday': 0.4, 'short_term': 0.4, 'long_term': 0.2}
        
        for period, weight in weights.items():
            if period in ai_predictions:
                pred = ai_predictions[period]
                ai_trends.append(pred.trend_pct * pred.confidence * weight)
        
        avg_ai_trend = sum(ai_trends) if ai_trends else 0
        
        # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã®ãƒã‚¤ã‚¢ã‚¹
        total_signals = technical_signals.total_buy_score + technical_signals.total_sell_score
        if total_signals > 0:
            tech_bias = (technical_signals.total_buy_score - technical_signals.total_sell_score) / total_signals * 10
        else:
            tech_bias = 0
        
        # çµ±åˆåˆ¤å®šï¼ˆAIäºˆæ¸¬ã‚’å„ªå…ˆï¼‰
        combined_signal = avg_ai_trend * 0.7 + tech_bias * 0.3
        
        if combined_signal > 2:
            return "bullish"
        elif combined_signal < -2:
            return "bearish"
        else:
            return "neutral"

# ============================================================================
# è¨­å®šç®¡ç†ã‚¯ãƒ©ã‚¹ (æ”¹è‰¯ç‰ˆ)
# ============================================================================

class AdvisorConfigLoader:
    """æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ç”¨è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ãƒ»ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    DEFAULT_ADVISOR_CONFIG = {
        "report_filename_template": "market_analysis_report_{profile}.json",
        "profiles": ProfileConstants.UNIFIED_PROFILES,
        "technical_analysis_settings": {
            "buy_signal_columns": ["golden_cross", "RSI_buy_signal", "MACD_buy_signal", "BB_buy_signal"],
            "sell_signal_columns": ["death_cross", "RSI_sell_signal", "MACD_sell_signal", "BB_sell_signal"],
            "recent_days_for_signal_count": 5,
            "ma_cross_signal_recency_days": 10
        },
    }

    def __init__(self, config_path: str = "advisor_config.json", logger_manager=None):
        self.logger = self._setup_logger(logger_manager)
        self.config_path = config_path
        
        self.config_data = self._load_config_safe(config_path)
        self.config_data = self._deep_update(self.DEFAULT_ADVISOR_CONFIG.copy(), self.config_data)

        self.current_profile_name = "natural"
        self.set_profile(self.current_profile_name)
        self.logger.info(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼è¨­å®šã‚’ '{config_path}' ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã€‚ç¾åœ¨ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile_name}")

    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªãƒ­ã‚¬ãƒ¼
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger

    def _load_config_safe(self, config_path: str) -> Dict[str, Any]:
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å®‰å…¨ãªèª­ã¿è¾¼ã¿"""
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                self.logger.warning(f"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ« '{config_path}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
                return {}
        except Exception as e:
            self.logger.error(f"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _deep_update(self, base_dict: Dict, update_dict: Dict) -> Dict:
        """è¾æ›¸ã®æ·±ã„ãƒãƒ¼ã‚¸"""
        for key, value in update_dict.items():
            if isinstance(value, dict) and key in base_dict and isinstance(base_dict[key], dict):
                base_dict[key] = self._deep_update(base_dict[key], value)
            else:
                base_dict[key] = value
        return base_dict

    def set_profile(self, profile_name: str) -> bool:
        """ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®š"""
        if profile_name in ProfileConstants.UNIFIED_PROFILES:
            self.current_profile_name = profile_name
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ '{profile_name}' ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚")
            return True
        else:
            self.logger.warning(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« '{profile_name}' ã¯è¨­å®šã«å­˜åœ¨ã—ã¾ã›ã‚“ã€‚'{self.current_profile_name}' ã‚’ç¶­æŒã—ã¾ã™ã€‚")
            return False

    def get_profile_list(self) -> List[str]:
        return list(ProfileConstants.UNIFIED_PROFILES.keys())

    def get_current_profile_config(self) -> Dict[str, Any]:
        return ProfileConstants.UNIFIED_PROFILES.get(self.current_profile_name, ProfileConstants.UNIFIED_PROFILES["natural"])

    def get_profile_description(self) -> str:
        profile_conf = self.get_current_profile_config()
        return profile_conf.get("profile_description", "èª¬æ˜ãªã—")

    def get_config_value(self, key_path: str, default: Optional[Any] = None) -> Any:
        keys = key_path.split('.')
        
        # 1. ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰è¨­å®š
        val = self.get_current_profile_config()
        for key in keys:
            if isinstance(val, dict) and key in val:
                val = val[key]
            else:
                val = None
                break
        if val is not None:
            return val
        
        # 2. å…±é€šè¨­å®š
        val_common = self.config_data
        for key in keys:
            if isinstance(val_common, dict) and key in val_common:
                val_common = val_common[key]
            else:
                return default
        return val_common

# ============================================================================
# ãƒ‡ãƒ¼ã‚¿å‡¦ç†å°‚ç”¨ã‚¯ãƒ©ã‚¹
# ============================================================================

class MarketDataProcessor:
    """å¸‚å ´ãƒ‡ãƒ¼ã‚¿å‡¦ç†å°‚ç”¨ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, logger_manager=None):
        self.logger = self._setup_logger(logger_manager)
    
    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger
    
    def get_sp500_dataframe(self, market_data_dict: Dict[str, Dict[str, Any]]) -> Optional[pd.DataFrame]:
        """å¸‚å ´ãƒ‡ãƒ¼ã‚¿è¾æ›¸ã‹ã‚‰S&P500 DataFrameã‚’å®‰å…¨ã«å–å¾—"""
        try:
            for key in ["^GSPC", "SP500", "SPX", "sp500"]:
                if key in market_data_dict:
                    data = market_data_dict[key]
                    if isinstance(data, dict) and "df" in data and data["df"] is not None and not data["df"].empty:
                        self.logger.info(f"S&P500ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ ({key}): {len(data['df'])}è¡Œ")
                        return data["df"]
                    elif isinstance(data, pd.DataFrame) and not data.empty:
                        self.logger.info(f"S&P500ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ ({key}): {len(data)}è¡Œ")
                        return data
            self.logger.error("S&P500ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return pd.DataFrame()
        except Exception as e:
            self.logger.error(f"S&P500ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return pd.DataFrame()

    def get_vix_value(self, market_data_dict: Dict, sp500_df: pd.DataFrame) -> float:
        """VIXå€¤ã‚’å®‰å…¨ã«å–å¾—"""
        try:
            # S&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç›´æ¥å–å¾—ã‚’å„ªå…ˆ
            if not sp500_df.empty and 'VIX' in sp500_df.columns:
                vix_series = sp500_df['VIX'].dropna()
                if len(vix_series) > 0:
                    return float(vix_series.iloc[-1])
            
            # å¸‚å ´ãƒ‡ãƒ¼ã‚¿è¾æ›¸ã‹ã‚‰å–å¾—
            for key in ["VIX", "^VIX", "vix", "volatility"]:
                if key in market_data_dict:
                    vix_data = market_data_dict[key]
                    if isinstance(vix_data, dict):
                        if "df" in vix_data and not vix_data["df"].empty and "Close" in vix_data["df"].columns:
                            return float(vix_data["df"]["Close"].iloc[-1])
                        elif "Close" in vix_data and isinstance(vix_data["Close"], list) and len(vix_data["Close"]) > 0:
                            return float(vix_data["Close"][-1])
                    elif isinstance(vix_data, (int, float)):
                        return float(vix_data)
            
            # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã‹ã‚‰æ¨å®š
            if not sp500_df.empty:
                returns = sp500_df['Close'].pct_change().dropna().tail(20)
                if len(returns) > 0:
                    volatility = returns.std() * np.sqrt(252) * 100
                    estimated_vix = min(80, max(10, volatility))
                    self.logger.info(f"VIXæ¨å®šå€¤: {estimated_vix:.1f} (ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã‹ã‚‰è¨ˆç®—)")
                    return estimated_vix
            
            self.logger.warning(f"VIXå€¤ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ {MarketConstants.VIX_DEFAULT} ã‚’ä½¿ç”¨")
            return MarketConstants.VIX_DEFAULT
            
        except Exception as e:
            self.logger.error(f"VIXå–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return MarketConstants.VIX_DEFAULT

    def get_current_market_status(self, sp500_df: pd.DataFrame, market_data_dict: Dict) -> MarketStatus:
        """ç¾åœ¨ã®å¸‚å ´çŠ¶æ³ã‚’å–å¾—"""
        if sp500_df is None or sp500_df.empty:
            raise ValidationError("S&P500ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³")
        
        try:
            latest_row = sp500_df.iloc[-1]
            current_price = float(latest_row["Close"])
            
            # æ—¥æ¬¡å¤‰å‹•è¨ˆç®—
            if len(sp500_df) > 1:
                prev_price = float(sp500_df["Close"].iloc[-2])
                daily_change = ((current_price - prev_price) / prev_price) * 100 if prev_price != 0 else 0
            else:
                daily_change = 0
            
            # VIXå€¤å–å¾—
            vix_value = self.get_vix_value(market_data_dict, sp500_df)
            
            # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£è¨ˆç®—
            if len(sp500_df) >= 5:
                volatility_5d = float(sp500_df["Close"].pct_change().dropna().tail(5).std() * np.sqrt(252) * 100)
            else:
                volatility_5d = 0
            
            return MarketStatus(
                current_price=current_price,
                last_price_date=sp500_df.index[-1].strftime("%Y-%m-%d"),
                daily_change=daily_change,
                volatility_5d=volatility_5d,
                vix=vix_value,
                vix_level=self._categorize_vix(vix_value),
                volume=float(latest_row.get("Volume", 0))
            )
            
        except Exception as e:
            self.logger.error(f"å¸‚å ´çŠ¶æ³å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            raise ValidationError(f"å¸‚å ´çŠ¶æ³å–å¾—ã«å¤±æ•—: {e}")

    def _categorize_vix(self, vix_value: float) -> str:
        """VIXå€¤ã®ã‚«ãƒ†ã‚´ãƒªåˆ†é¡"""
        if vix_value < 15:
            return "ä½ä½å®‰å®š"
        elif vix_value < 25:
            return "é€šå¸¸ç¯„å›²"
        elif vix_value < 35:
            return "è­¦æˆ’ãƒ¬ãƒ™ãƒ«"
        else:
            return "ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«"

# ============================================================================
# AIäºˆæ¸¬åˆ†æå°‚ç”¨ã‚¯ãƒ©ã‚¹
# ============================================================================

class PredictionAnalyzer:
    """AIäºˆæ¸¬åˆ†æå°‚ç”¨ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, logger_manager=None):
        self.logger = self._setup_logger(logger_manager)
    
    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger

    def analyze_model_predictions(self, trained_models_results: Dict, current_price: float) -> Dict[str, PredictionResult]:
        """ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ã®çµ±åˆåˆ†æ"""
        predictions = {}
        
        try:
            self.logger.info("=== AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼ç”Ÿæˆé–‹å§‹ï¼ˆä¿®æ­£ç‰ˆï¼‰ ===")
            
            for model_key, model_result in trained_models_results.items():
                if not isinstance(model_result, dict):
                    continue
                    
                self.logger.info(f"å‡¦ç†ä¸­ã®ãƒ¢ãƒ‡ãƒ«: {model_key}")
                
                # å˜ä¸€ãƒ¢ãƒ‡ãƒ«ã®å‡¦ç†
                pred_result = self._process_single_model(model_result, model_key, current_price)
                
                # ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹åˆ†é¡
                if 'long' in model_key.lower():
                    predictions["long_term"] = pred_result
                elif 'short' in model_key.lower():
                    predictions["short_term"] = pred_result
                elif 'nextday' in model_key.lower() or 'next' in model_key.lower():
                    predictions["nextday"] = pred_result
                else:
                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯é•·æœŸæ‰±ã„
                    predictions["long_term"] = pred_result

            # é•·æœŸäºˆæ¸¬ãŒãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if "long_term" not in predictions and predictions:
                # æœ€ã‚‚ä¿¡é ¼æ€§ã®é«˜ã„ãƒ¢ãƒ‡ãƒ«ã‚’é•·æœŸäºˆæ¸¬ã¨ã—ã¦ä½¿ç”¨
                best_pred = max(predictions.values(), key=lambda x: x.confidence)
                predictions["long_term"] = best_pred
                self.logger.info(f"ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: {best_pred.model_type} ã‹ã‚‰é•·æœŸäºˆæ¸¬ç”Ÿæˆ")
            
            self.logger.info(f"æœ€çµ‚çš„ãªAIäºˆæ¸¬: {len(predictions)}å€‹ã®ãƒ¢ãƒ‡ãƒ«")
            return predictions
            
        except Exception as e:
            self.logger.error(f"AIäºˆæ¸¬åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _process_single_model(self, model_result: Dict, model_type: str, current_price: float) -> PredictionResult:
        """å˜ä¸€ãƒ¢ãƒ‡ãƒ«ã®å‡¦ç†"""
        try:
            # äºˆæ¸¬ä¾¡æ ¼ã®æŠ½å‡º
            predicted_price = self._extract_prediction_price(model_result, model_type)
            
            # ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—
            if current_price > 0:
                trend_pct = ((predicted_price - current_price) / current_price) * 100
            else:
                trend_pct = 0
            
            # ä¿¡é ¼åº¦è¨ˆç®—
            mape = model_result.get('mape_test', 50)
            confidence = ConfidenceCalculator.calculate_confidence(mape)
            
            # äºˆæ¸¬å€¤ã®å¦¥å½“æ€§æ¤œè¨¼
            validated_price = self._validate_prediction(current_price, predicted_price, model_type)
            
            self.logger.info(f"{model_type}: äºˆæ¸¬={validated_price:.2f}, ãƒˆãƒ¬ãƒ³ãƒ‰={trend_pct:.2f}%, ä¿¡é ¼åº¦={confidence:.3f}")
            
            return PredictionResult(
                trend_pct=trend_pct,
                confidence=confidence,
                price=validated_price,
                model_type=model_type,
                mape=mape
            )
            
        except Exception as e:
            self.logger.error(f"{model_type} å˜ä¸€ãƒ¢ãƒ‡ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return PredictionResult(
                trend_pct=0.0,
                confidence=0.5,
                price=current_price or MarketConstants.DEFAULT_SP500_PRICE,
                model_type=model_type
            )

    def _extract_prediction_price(self, model_result: Dict, model_type: str) -> float:
        """äºˆæ¸¬ä¾¡æ ¼ã®æŠ½å‡º"""
        try:
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: latest_prediction_original
            if 'latest_prediction_original' in model_result:
                latest_pred_raw = model_result['latest_prediction_original']
                
                if isinstance(latest_pred_raw, (list, np.ndarray)) and len(latest_pred_raw) > 0:
                    if model_type == 'nextday':
                        return float(latest_pred_raw[0])
                    else:
                        return float(latest_pred_raw[-1])
                elif isinstance(latest_pred_raw, (int, float)):
                    return float(latest_pred_raw)
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: y_pred_original_test
            if 'y_pred_original_test' in model_result:
                pred_data = model_result['y_pred_original_test']
                if isinstance(pred_data, list) and len(pred_data) > 0:
                    return float(pred_data[-1])
            
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            self.logger.warning(f"{model_type}: äºˆæ¸¬ä¾¡æ ¼ã®æŠ½å‡ºã«å¤±æ•—")
            return MarketConstants.DEFAULT_SP500_PRICE
            
        except Exception as e:
            self.logger.error(f"{model_type} äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return MarketConstants.DEFAULT_SP500_PRICE

    def _validate_prediction(self, current_price: float, predicted_price: float, prediction_type: str) -> float:
        """äºˆæ¸¬å€¤ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ç•°å¸¸å€¤ã‚’è£œæ­£"""
        try:
            if current_price == 0:
                self.logger.warning(f"{prediction_type}äºˆæ¸¬ã®æ¤œè¨¼: ç¾åœ¨ä¾¡æ ¼ãŒ0ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—")
                return predicted_price

            change_pct = ((predicted_price - current_price) / current_price) * 100
            thresholds = {
                'nextday': (-5, 5),
                'short': (-15, 15), 
                'long': (-25, 25)
            }
            min_change, max_change = thresholds.get(prediction_type, (-30, 30))
            
            if change_pct < min_change or change_pct > max_change:
                self.logger.warning(f"{prediction_type}äºˆæ¸¬ãŒç•°å¸¸å€¤: {change_pct:.2f}% â†’ è£œæ­£å®Ÿè¡Œ")
                corrected_change = np.sign(change_pct) * min(abs(change_pct), abs(max_change))
                corrected_price = current_price * (1 + corrected_change / 100)
                self.logger.info(f"{prediction_type}äºˆæ¸¬è£œæ­£: {predicted_price:.2f} â†’ {corrected_price:.2f}")
                return corrected_price
            
            return predicted_price
            
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬å€¤æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return current_price

# ============================================================================
# ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æå°‚ç”¨ã‚¯ãƒ©ã‚¹
# ============================================================================

class TechnicalAnalyzer:
    """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æå°‚ç”¨ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, logger_manager=None):
        self.logger = self._setup_logger(logger_manager)
    
    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger

    def analyze_technical_signals(self, sp500_df: pd.DataFrame) -> TechnicalSignals:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚·ã‚°ãƒŠãƒ«ã®ç·åˆåˆ†æ"""
        if sp500_df.empty:
            return TechnicalSignals(
                total_buy_score=0,
                total_sell_score=0,
                ma_cross_status="ãƒ‡ãƒ¼ã‚¿ãªã—",
                rsi_signal="ãƒ‡ãƒ¼ã‚¿ãªã—"
            )
        
        try:
            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
            tech_indicators = self._calculate_technical_indicators(sp500_df)
            
            # ã‚·ã‚°ãƒŠãƒ«ã‚¹ã‚³ã‚¢è¨ˆç®—
            buy_score, sell_score = self._calculate_signal_scores(tech_indicators)
            
            # ã‚¯ãƒ­ã‚¹çŠ¶æ³ç¢ºèª
            ma_cross_status = self._analyze_ma_cross(sp500_df)
            
            result = TechnicalSignals(
                total_buy_score=buy_score,
                total_sell_score=sell_score,
                ma_cross_status=ma_cross_status,
                rsi_signal=tech_indicators.get("rsi_signal", "ä¸­ç«‹"),
                rsi_current=tech_indicators.get("rsi_current", 50.0),
                recent_days_for_count=15
            )
            
            self.logger.info(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æå®Œäº†: è²·ã„={buy_score}, å£²ã‚Š={sell_score}")
            return result
            
        except Exception as e:
            self.logger.error(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return TechnicalSignals(
                total_buy_score=0,
                total_sell_score=0,
                ma_cross_status="åˆ†æã‚¨ãƒ©ãƒ¼",
                rsi_signal="åˆ†æã‚¨ãƒ©ãƒ¼"
            )

    def _calculate_technical_indicators(self, sp500_df: pd.DataFrame) -> Dict[str, Any]:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—"""
        tech_data = {}
        
        try:
            df = sp500_df.copy()
            current_price = df['Close'].iloc[-1]
            
            # RSIè¨ˆç®—
            rsi_current = self._calculate_rsi(df)
            if pd.notna(rsi_current):
                tech_data["rsi_current"] = float(rsi_current)
                tech_data["rsi_signal"] = self._get_rsi_signal(rsi_current)
            
            # ç§»å‹•å¹³å‡ç·šåˆ†æ
            ma_signals = self._analyze_moving_averages(df, current_price)
            if ma_signals:
                tech_data["ma_signals"] = ma_signals
            
            return tech_data
            
        except Exception as e:
            self.logger.error(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _calculate_rsi(self, df: pd.DataFrame) -> float:
        """RSIè¨ˆç®—"""
        try:
            if 'RSI' in df.columns:
                return df['RSI'].iloc[-1]
            elif len(df) >= 14:
                delta = df['Close'].diff()
                gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
                loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
                rs = gain / loss
                rsi_series = 100 - (100 / (1 + rs))
                return rsi_series.iloc[-1] if not rsi_series.empty else np.nan
            else:
                return np.nan
        except Exception as e:
            self.logger.error(f"RSIè¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return np.nan

    def _get_rsi_signal(self, rsi_value: float) -> str:
        """RSIã‚·ã‚°ãƒŠãƒ«åˆ¤å®š"""
        if rsi_value >= MarketConstants.RSI_OVERBOUGHT:
            return "éè²·ã„"
        elif rsi_value <= MarketConstants.RSI_OVERSOLD:
            return "éå£²ã‚Š"
        else:
            return "ä¸­ç«‹"

    def _analyze_moving_averages(self, df: pd.DataFrame, current_price: float) -> Dict[str, str]:
        """ç§»å‹•å¹³å‡ç·šåˆ†æ"""
        ma_signals = {}
        
        try:
            # æ—¢å­˜ã®ç§»å‹•å¹³å‡ç·šã‚’ä½¿ç”¨
            ma_columns = [col for col in df.columns if col.startswith('MA') and col[2:].isdigit()]
            
            if ma_columns:
                for ma_col in ['MA5', 'MA20', 'MA50', 'MA60', 'MA120']:
                    if ma_col in df.columns and pd.notna(df[ma_col].iloc[-1]):
                        ma_signals[f"price_vs_{ma_col.lower()}"] = "above" if current_price > df[ma_col].iloc[-1] else "below"
                
                if 'MA5' in df.columns and 'MA20' in df.columns:
                    if pd.notna(df['MA5'].iloc[-1]) and pd.notna(df['MA20'].iloc[-1]):
                        ma_signals["ma5_vs_ma20"] = "above" if df['MA5'].iloc[-1] > df['MA20'].iloc[-1] else "below"
            
            elif len(df) >= 50:
                # ç§»å‹•å¹³å‡ç·šã‚’è¨ˆç®—
                df['MA5'] = df['Close'].rolling(5).mean()
                df['MA20'] = df['Close'].rolling(20).mean()
                df['MA50'] = df['Close'].rolling(50).mean()
                
                latest = df.iloc[-1]
                if pd.notna(latest['MA5']):
                    ma_signals["price_vs_ma5"] = "above" if current_price > latest['MA5'] else "below"
                if pd.notna(latest['MA20']):
                    ma_signals["price_vs_ma20"] = "above" if current_price > latest['MA20'] else "below"
                if pd.notna(latest['MA50']):
                    ma_signals["price_vs_ma50"] = "above" if current_price > latest['MA50'] else "below"
                if pd.notna(latest['MA5']) and pd.notna(latest['MA20']):
                    ma_signals["ma5_vs_ma20"] = "above" if latest['MA5'] > latest['MA20'] else "below"
            
            return ma_signals
            
        except Exception as e:
            self.logger.error(f"ç§»å‹•å¹³å‡ç·šåˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _analyze_ma_cross(self, sp500_df: pd.DataFrame) -> str:
        """ç§»å‹•å¹³å‡ã‚¯ãƒ­ã‚¹åˆ†æ"""
        try:
            if 'golden_cross' in sp500_df.columns and 'death_cross' in sp500_df.columns:
                recent_data = sp500_df.tail(30)
                if recent_data['golden_cross'].any():
                    return "ç›´è¿‘ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¯ãƒ­ã‚¹ç™ºç”Ÿ"
                elif recent_data['death_cross'].any():
                    return "ç›´è¿‘ãƒ‡ãƒƒãƒ‰ã‚¯ãƒ­ã‚¹ç™ºç”Ÿ"
                else:
                    return "MAã‚¯ãƒ­ã‚¹ã¯30æ—¥ä»¥å†…ã«ãªã—"
            else:
                return "MAã‚¯ãƒ­ã‚¹ãƒ‡ãƒ¼ã‚¿ãªã—"
        except Exception as e:
            self.logger.error(f"MAã‚¯ãƒ­ã‚¹åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return "MAã‚¯ãƒ­ã‚¹åˆ†æã‚¨ãƒ©ãƒ¼"

    def _calculate_signal_scores(self, tech_indicators: Dict[str, Any]) -> Tuple[int, int]:
        """ã‚·ã‚°ãƒŠãƒ«ã‚¹ã‚³ã‚¢ã®è¨ˆç®—"""
        buy_score = 0
        sell_score = 0
        
        try:
            # RSIã‚·ã‚°ãƒŠãƒ«
            if "rsi_signal" in tech_indicators:
                if tech_indicators["rsi_signal"] == "éå£²ã‚Š":
                    buy_score += 3
                elif tech_indicators["rsi_signal"] == "éè²·ã„":
                    sell_score += 3
                else:
                    rsi_val = tech_indicators.get("rsi_current", 50)
                    if rsi_val < 40:
                        buy_score += 1
                    elif rsi_val > 60:
                        sell_score += 1
            
            # ç§»å‹•å¹³å‡ã‚·ã‚°ãƒŠãƒ«
            if "ma_signals" in tech_indicators:
                ma_s = tech_indicators["ma_signals"]
                above_count = sum(1 for k, v in ma_s.items() if k.startswith("price_vs_") and v == "above")
                below_count = sum(1 for k, v in ma_s.items() if k.startswith("price_vs_") and v == "below")
                
                if above_count > below_count:
                    buy_score += above_count
                elif below_count > above_count:
                    sell_score += below_count
                
                if ma_s.get("ma5_vs_ma20") == "above":
                    buy_score += 1
                elif ma_s.get("ma5_vs_ma20") == "below":
                    sell_score += 1
            
            return buy_score, sell_score
            
        except Exception as e:
            self.logger.error(f"ã‚·ã‚°ãƒŠãƒ«ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return 0, 0

# ============================================================================
# æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¯ãƒ©ã‚¹ (çµ±åˆç‰ˆ)
# ============================================================================

class InvestmentAdvisor:
    """AIäºˆæ¸¬ä¿®æ­£ç‰ˆæŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    
    def __init__(self, market_data_dict: Dict, trained_models_results: Dict, 
                 logger_manager=None, initial_profile_name: str = "natural"):
        self.logger = self._setup_logger(logger_manager)
        self.market_data_dict = market_data_dict
        self.trained_models_results = trained_models_results
        self.current_profile = initial_profile_name
        
        # çµ±ä¸€ã•ã‚ŒãŸãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å®šç¾©ä½¿ç”¨
        self.profile_config = ProfileConstants.UNIFIED_PROFILES.get(
            initial_profile_name, ProfileConstants.UNIFIED_PROFILES["natural"]
        )
        
        # å„ç¨®ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼ã®åˆæœŸåŒ–
        self.data_processor = MarketDataProcessor(logger_manager)
        self.prediction_analyzer = PredictionAnalyzer(logger_manager)
        self.technical_analyzer = TechnicalAnalyzer(logger_manager)
        
        # ãƒ‡ãƒ¼ã‚¿å–å¾—
        self.sp500_df = self.data_processor.get_sp500_dataframe(market_data_dict)
        self.calculation_errors = []
        
        # åˆæœŸåŒ–ãƒ­ã‚°
        self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªå¸‚å ´ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ¼: {list(self.market_data_dict.keys())}")
        self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«çµæœã‚­ãƒ¼: {list(self.trained_models_results.keys())}")
        self.logger.info(f"InvestmentAdvisoråˆæœŸåŒ–å®Œäº† - ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile}")

    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger

    def generate_investment_advice(self) -> Dict[str, Any]:
        """æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã®ç”Ÿæˆï¼ˆãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆï¼‰"""
        try:
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹ (ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile})")
            
            # ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨åˆ†æ
            market_status = self.data_processor.get_current_market_status(self.sp500_df, self.market_data_dict)
            predictions = self.prediction_analyzer.analyze_model_predictions(
                self.trained_models_results, market_status.current_price
            )
            tech_signals = self.technical_analyzer.analyze_technical_signals(self.sp500_df)
            
            # ç·åˆè©•ä¾¡
            assessment = self._generate_comprehensive_market_assessment(
                market_status, predictions, tech_signals
            )
            
            # æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆ
            advice = self._generate_investment_advice_from_assessment(assessment, predictions)
            
            # ãƒ¬ãƒãƒ¼ãƒˆæ§‹ç¯‰
            report = {
                "metadata": {
                    "generated_at": datetime.now().isoformat(),
                    "profile": self.current_profile,
                    "calculation_errors": self.calculation_errors
                },
                "market_analysis": {
                    "current_status": market_status.__dict__,
                    "ai_predictions": {k: v.__dict__ for k, v in predictions.items()},
                    "technical_signals": tech_signals.__dict__
                },
                "assessment": assessment.__dict__,
                "investment_advice": advice
            }
            
            return report
            
        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"error": str(e)}

    def _generate_comprehensive_market_assessment(self, market_status: MarketStatus, 
                                                predictions: Dict[str, PredictionResult], 
                                                tech_signals: TechnicalSignals) -> MarketAssessment:
        """ç·åˆå¸‚å ´è©•ä¾¡ã‚’ç”Ÿæˆ"""
        try:
            # AIäºˆæ¸¬ã®é‡ã¿ä»˜ã‘çµ±åˆ
            weights = {'nextday': 0.4, 'short_term': 0.4, 'long_term': 0.2}
            weighted_trend = 0
            total_weight = 0
            
            for period, weight in weights.items():
                if period in predictions:
                    pred = predictions[period]
                    actual_weight = weight * pred.confidence
                    weighted_trend += pred.trend_pct * actual_weight
                    total_weight += actual_weight
            
            final_trend = weighted_trend / total_weight if total_weight > 0 else 0
            final_confidence = total_weight / sum(weights.values()) if sum(weights.values()) > 0 else 0.5
            
            # ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ©ãƒ™ãƒ«æ±ºå®š
            trend_label = TrendJudge.judge_overall_trend(predictions, tech_signals)
            
            # ãƒªã‚¹ã‚¯è©•ä¾¡
            risk_level = self._assess_risk_level(market_status, final_confidence)
            
            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢
            total_signals = tech_signals.total_buy_score + tech_signals.total_sell_score
            tech_score = tech_signals.total_buy_score / total_signals if total_signals > 0 else 0.5
            
            return MarketAssessment(
                trend=trend_label,
                confidence=final_confidence,
                risk_level=risk_level,
                tech_score=tech_score,
                ai_reliability=final_confidence
            )
            
        except Exception as e:
            self.logger.error(f"ç·åˆå¸‚å ´è©•ä¾¡ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return MarketAssessment("neutral", 0.5, "medium", 0.5, 0.5)

    def _assess_risk_level(self, market_status: MarketStatus, confidence: float) -> str:
        """ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ã®è©•ä¾¡"""
        risk_factors = 0
        
        # VIXã«ã‚ˆã‚‹ãƒªã‚¹ã‚¯
        if market_status.vix > 30:
            risk_factors += 3
        elif market_status.vix > 25:
            risk_factors += 2
        elif market_status.vix > 20:
            risk_factors += 1
        
        # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã«ã‚ˆã‚‹ãƒªã‚¹ã‚¯
        if market_status.volatility_5d > 25:
            risk_factors += 2
        elif market_status.volatility_5d > 15:
            risk_factors += 1
        
        # ä¿¡é ¼åº¦ã«ã‚ˆã‚‹ãƒªã‚¹ã‚¯
        if confidence < 0.4:
            risk_factors += 1
        
        if risk_factors >= 5:
            return "high"
        elif risk_factors >= 2:
            return "medium"
        else:
            return "low"

    def _generate_investment_advice_from_assessment(self, assessment: MarketAssessment, 
                                                  predictions: Dict[str, PredictionResult]) -> Dict[str, Any]:
        """è©•ä¾¡çµæœã‹ã‚‰æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ"""
        try:
            confidence_threshold = self.profile_config.get("confidence_threshold", 0.6)
            
            # é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰å–å¾—
            ai_trend = predictions.get("long_term", PredictionResult(0, 0, 0, "none")).trend_pct
            
            # åŸºæœ¬çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ±ºå®š
            primary_action, action_strength, reason = self._determine_primary_action(
                assessment, ai_trend, confidence_threshold
            )
            
            # è­¦å‘Šç”Ÿæˆ
            warnings = self._generate_warnings(ai_trend, assessment)
            
            # ã‚¢ãƒ‰ãƒã‚¤ã‚¹æ§‹ç¯‰
            return {
                "primary_action": primary_action,
                "action_strength": action_strength,
                "risk_assessment": f"{assessment.risk_level}ãƒªã‚¹ã‚¯",
                "confidence_score": assessment.confidence,
                "profile_adjusted_advice": {
                    "advice_text": f"ã€{self.current_profile.upper()}ã€‘{primary_action}æ¨å¥¨ï¼ˆ{action_strength}ï¼‰- {reason}",
                    "position_sizing": self._get_position_sizing_advice(primary_action, assessment.risk_level)
                },
                "key_factors": [
                    f"AIãƒˆãƒ¬ãƒ³ãƒ‰: {ai_trend:+.1f}%",
                    f"å¸‚å ´ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.trend}",
                    f"ä¿¡é ¼åº¦: {assessment.confidence:.1%}",
                    f"ãƒªã‚¹ã‚¯: {assessment.risk_level}",
                    f"AIä¿¡é ¼åº¦: {assessment.ai_reliability:.1%}"
                ],
                "recommendations": self._get_basic_recommendations(primary_action),
                "warnings": warnings[:5]
            }
            
        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "error": str(e),
                "primary_action": "HOLD",
                "action_strength": "å¼±",
                "risk_assessment": "ãƒ‡ãƒ¼ã‚¿ä¸è¶³é«˜ãƒªã‚¹ã‚¯"
            }

    def _determine_primary_action(self, assessment: MarketAssessment, ai_trend: float, 
                                confidence_threshold: float) -> Tuple[str, str, str]:
        """ä¸»è¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®æ±ºå®š"""
        if assessment.confidence < confidence_threshold:
            return "HOLD", "å¼±", f"ä¿¡é ¼åº¦{assessment.confidence:.1%}ãŒé–¾å€¤{confidence_threshold:.1%}æœªæº€"
        
        if assessment.trend == "bullish" and assessment.risk_level != "high":
            if abs(ai_trend) > 1 and ai_trend > 0:
                strength = "å¼·" if assessment.confidence > 0.8 and ai_trend > 3 else "ä¸­"
                return "BUY", strength, f"ä¸Šæ˜‡ãƒˆãƒ¬ãƒ³ãƒ‰(AI: +{ai_trend:.1f}%)"
            else:
                return "BUY", "å¼±", "ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ä¸Šæ˜‡ã ãŒAIäºˆæ¸¬ä¸æ˜ç¢º"
        
        elif assessment.trend == "bearish" or (abs(ai_trend) > 1 and ai_trend < -2):
            strength = "å¼·" if ai_trend < -3 else "ä¸­"
            return "SELL", strength, f"ä¸‹é™ãƒˆãƒ¬ãƒ³ãƒ‰(AI: {ai_trend:.1f}%)"
        
        else:
            return "HOLD", "ä¸­", "æ˜ç¢ºãªãƒˆãƒ¬ãƒ³ãƒ‰ãªã—"

    def _generate_warnings(self, ai_trend: float, assessment: MarketAssessment) -> List[str]:
        """è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç”Ÿæˆ"""
        warnings = []
        
        if ai_trend < -5:
            warnings.append(f"ğŸš¨ AIäºˆæ¸¬ãŒå¤§å¹…ä¸‹è½è­¦å‘Š: {ai_trend:.1f}%")
        elif ai_trend < -2:
            warnings.append(f"âš ï¸ AIäºˆæ¸¬ãŒä¸‹è½ç¤ºå”†: {ai_trend:.1f}%")
        elif ai_trend > 5:
            warnings.append(f"ğŸ“ˆ AIäºˆæ¸¬ãŒå¤§å¹…ä¸Šæ˜‡ç¤ºå”†: +{ai_trend:.1f}%")
        
        if assessment.risk_level == "high":
            warnings.append("âš ï¸ é«˜ãƒªã‚¹ã‚¯å¸‚å ´ç’°å¢ƒ")
        
        if assessment.confidence < 0.4:
            warnings.append("âš ï¸ äºˆæ¸¬ä¿¡é ¼åº¦ ä½")
        
        if assessment.ai_reliability < 0.4:
            warnings.append("âš ï¸ AIäºˆæ¸¬ä¿¡é ¼æ€§ ä½")
        
        warnings.extend(["æŠ•è³‡ã¯è‡ªå·±è²¬ä»»ã§ã€‚", "ä½™è£•è³‡é‡‘ã§ã®æŠ•è³‡ã‚’ã€‚"])
        
        return warnings

    def _get_position_sizing_advice(self, action: str, risk_level: str) -> str:
        """ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹"""
        if action == "HOLD":
            return "ç¾çŠ¶ç¶­æŒ"
        
        profile_multipliers = {"conservative": 0.5, "natural": 1.0, "aggressive": 1.5}
        risk_multipliers = {"low": 1.0, "medium": 0.8, "high": 0.5}
        
        multiplier = profile_multipliers.get(self.current_profile, 1.0) * risk_multipliers.get(risk_level, 0.8)
        return f"è³‡é‡‘ã®{int(10 * multiplier)}%ç¨‹åº¦"

    def _get_basic_recommendations(self, action: str) -> List[str]:
        """åŸºæœ¬çš„ãªæ¨å¥¨äº‹é …"""
        recs = {
            "BUY": ["ETF/ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŠ•è³‡æ¤œè¨", "ãƒ‰ãƒ«ã‚³ã‚¹ãƒˆå¹³å‡æ³•", "ç·Šæ€¥è³‡é‡‘ç¢ºä¿"],
            "SELL": ["æ®µéšçš„åˆ©ç¢ºæ¤œè¨", "ç¾é‡‘ãƒã‚¸ã‚·ãƒ§ãƒ³å¢—", "ç¨å‹™åŠ¹ç‡è€ƒæ…®"],
            "HOLD": ["ç¾ãƒã‚¸ã‚·ãƒ§ãƒ³ç¶­æŒ", "å¸‚å ´å‹•å‘ç›£è¦–", "æŠ•è³‡æ©Ÿä¼šæº–å‚™"]
        }
        return recs.get(action, recs["HOLD"])

    # ============================================================================
    # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ»è¡¨ç¤ºãƒ¡ã‚½ãƒƒãƒ‰
    # ============================================================================

    def generate_investment_report(self, save_to_json: bool = False, print_to_console: bool = True) -> bool:
        """æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆï¼ˆãƒ¡ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰"""
        try:
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™")
            report_data = self.generate_investment_advice()
            
            if "error" in report_data:
                self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {report_data['error']}")
                return False
            
            # äºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ã®ãƒ­ã‚°å‡ºåŠ›
            self._log_prediction_summary(report_data)
            
            if print_to_console:
                self._display_enhanced_report(report_data)
            
            if save_to_json:
                self._save_report_to_json(report_data)
            
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”ŸæˆãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
            return True
            
        except Exception as e:
            self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _log_prediction_summary(self, report_data: Dict[str, Any]):
        """äºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ã‚’ãƒ­ã‚°å‡ºåŠ›"""
        try:
            predictions = report_data.get("market_analysis", {}).get("ai_predictions", {})
            self.logger.info("=== AIäºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ ===")
            
            for model_name, pred_data in predictions.items():
                price = pred_data.get("price", 0)
                period_map = {"nextday": "ç¿Œæ—¥", "short_term": "çŸ­æœŸ", "long_term": "é•·æœŸ"}
                period = period_map.get(model_name, model_name)
                self.logger.info(f"{model_name}ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ä¾¡æ ¼: ${price:,.2f} ({period})")
            
            # ç¾åœ¨ä¾¡æ ¼ã¨ã®æ¯”è¼ƒ
            market_status = report_data.get("market_analysis", {}).get("current_status", {})
            current_price = market_status.get("current_price", 0)
            if current_price > 0:
                self.logger.info(f"ç¾åœ¨ä¾¡æ ¼: ${current_price:,.2f}")
                
                if "nextday" in predictions:
                    nextday_price = predictions["nextday"].get("price", 0)
                    if nextday_price > 0 and current_price > 0:
                        change = nextday_price - current_price
                        change_pct = (change / current_price) * 100
                        self.logger.info(f"ç¿Œæ—¥äºˆæ¸¬å¤‰åŒ–: ${change:+.2f} ({change_pct:+.2f}%)")
                        
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬ã‚µãƒãƒªãƒ¼ãƒ­ã‚°ã‚¨ãƒ©ãƒ¼: {e}")

    def _display_enhanced_report(self, report_data: Dict[str, Any]):
        """å¼·åŒ–ã•ã‚ŒãŸãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º"""
        try:
            print("\n" + "="*60)
            print("        ğŸ¯ AIæŠ•è³‡åˆ†æãƒ¬ãƒãƒ¼ãƒˆï¼ˆå¼·åŒ–ç‰ˆï¼‰ ğŸ¯")
            print("="*60)
            
            metadata = report_data.get('metadata', {})
            print(f"ğŸ“… ç”Ÿæˆæ—¥æ™‚: {metadata.get('generated_at', datetime.now().isoformat())}")
            print(f"ğŸ‘¤ æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile.upper()}")
            
            # AIäºˆæ¸¬ä¾¡æ ¼è¡¨ç¤º
            predictions = report_data.get("market_analysis", {}).get("ai_predictions", {})
            print("\nğŸ”® ã€AIäºˆæ¸¬ä¾¡æ ¼ã€‘")
            
            if "nextday" in predictions:
                price = predictions["nextday"].get("price", 0)
                print(f"ç¿Œæ—¥äºˆæ¸¬: ${price:,.2f}")
            if "short_term" in predictions:
                price = predictions["short_term"].get("price", 0)
                print(f"çŸ­æœŸäºˆæ¸¬ï¼ˆ20æ—¥å¾Œï¼‰: ${price:,.2f}")
            if "long_term" in predictions:
                price = predictions["long_term"].get("price", 0)
                print(f"é•·æœŸäºˆæ¸¬ï¼ˆ30æ—¥å¾Œï¼‰: ${price:,.2f}")
            
            # ç·åˆè©•ä¾¡è¡¨ç¤º
            assessment = report_data.get("assessment", {})
            advice = report_data.get("investment_advice", {})
            
            long_term_data = predictions.get("long_term", {})
            ai_trend = long_term_data.get("trend_pct", 0)
            ai_confidence = long_term_data.get("confidence", 0)
            
            print(f"\nğŸ¤– ã€AIäºˆæ¸¬åˆ†æ (ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ™ãƒ¼ã‚¹)ã€‘")
            print(f"é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬: {ai_trend:+.2f}%")
            print(f"AIä¿¡é ¼åº¦: {ai_confidence:.1%}")
            
            print(f"\nğŸ“Š ã€ç·åˆè©•ä¾¡ã€‘")
            print(f"ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.get('trend', 'N/A').upper()}")
            print(f"ä¿¡é ¼åº¦: {assessment.get('confidence', 0):.1%}")
            print(f"ãƒªã‚¹ã‚¯: {assessment.get('risk_level', 'N/A').upper()}")
            print(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢: {assessment.get('tech_score', 0):.2f}")
            print(f"AIä¿¡é ¼åº¦ (ç·åˆè©•ä¾¡æ™‚): {assessment.get('ai_reliability', 0):.1%}")
            
            print(f"\nğŸ’¡ ã€æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€‘")
            print(f"ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {advice.get('primary_action', 'N/A')}")
            print(f"å¼·åº¦: {advice.get('action_strength', 'N/A')}")
            
            profile_advice = advice.get("profile_adjusted_advice", {})
            if profile_advice:
                print(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¹: {profile_advice.get('advice_text', 'N/A')}")
                print(f"æ¨å¥¨ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚º: {profile_advice.get('position_sizing', 'N/A')}")
            
            # ä¸»è¦åˆ¤æ–­è¦å› 
            key_factors = advice.get("key_factors", [])
            if key_factors:
                print(f"\nğŸ” ã€ä¸»è¦åˆ¤æ–­è¦å› ã€‘")
                for factor in key_factors:
                    print(f"â€¢ {factor}")
            
            # è­¦å‘Šãƒ»æ³¨æ„äº‹é …
            warnings = advice.get("warnings", [])
            if warnings:
                print(f"\nâš ï¸ ã€è­¦å‘Šãƒ»æ³¨æ„äº‹é …ã€‘")
                for i, warning in enumerate(warnings[:3], 1):
                    print(f"{i}. {warning}")
            
            # å¸‚å ´çŠ¶æ³
            market = report_data.get("market_analysis", {}).get("current_status", {})
            if market and "error" not in market:
                print(f"\nğŸ“ˆ ã€å¸‚å ´çŠ¶æ³ã€‘")
                print(f"S&P500ä¾¡æ ¼: ${market.get('current_price', 0):.2f}")
                print(f"æ—¥æ¬¡å¤‰å‹•: {market.get('daily_change', 0):+.2f}%")
                print(f"VIXæŒ‡æ•°: {market.get('vix', 0):.1f} ({market.get('vix_level', 'N/A')})")
                print(f"5æ—¥ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£: {market.get('volatility_5d', 0):.1f}%")
            
            print("="*60)
            
        except Exception as e:
            self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {e}")

    def _save_report_to_json(self, report_data: Dict[str, Any]) -> bool:
        """JSONãƒ¬ãƒãƒ¼ãƒˆä¿å­˜"""
        try:
            profile_name = report_data.get("metadata", {}).get("profile", self.current_profile)
            timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"investment_report_{profile_name}_{timestamp_str}.json"
            
            return bool(self._save_analysis_report(report_data, filename))
            
        except Exception as e:
            self.logger.error(f"JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _save_analysis_report(self, report_data: Dict[str, Any], filename: str) -> Optional[str]:
        """åˆ†æãƒ¬ãƒãƒ¼ãƒˆã®ä¿å­˜"""
        def clean_data(obj):
            """NumPy/Pandaså‹ã‚’JSONäº’æ›ã«ã™ã‚‹"""
            if isinstance(obj, dict):
                return {k: clean_data(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [clean_data(v) for v in obj]
            elif pd.isna(obj):
                return None
            elif isinstance(obj, (np.integer, np.floating)):
                return float(obj)
            elif isinstance(obj, pd.Timestamp):
                return obj.isoformat()
            return obj
        
        try:
            cleaned_report_data = clean_data(report_data)
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(cleaned_report_data, f, ensure_ascii=False, indent=2, default=str)
            self.logger.info(f"ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜: {filename}")
            return filename
        except Exception as e:
            self.logger.error(f"ä¿å­˜ã‚¨ãƒ©ãƒ¼ ({filename}): {e}")
            return None

    # ============================================================================
    # ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼ãƒ»è¨­å®šç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
    # ============================================================================

    def validate_system(self) -> Dict[str, Any]:
        """ã‚·ã‚¹ãƒ†ãƒ ã®å¦¥å½“æ€§æ¤œè¨¼"""
        validation = {
            "market_data_loaded": self.sp500_df is not None and not self.sp500_df.empty,
            "ai_models_loaded": len(self.trained_models_results) > 0,
            "profile_valid": self.current_profile in ProfileConstants.UNIFIED_PROFILES,
            "config_accessible": self._get_current_config() is not None,
            "ai_predictions_working": False,
            "technical_analysis_working": False,
            "data_quality_score": 0.0
        }
        
        try:
            # AIäºˆæ¸¬æ©Ÿèƒ½ã®æ¤œè¨¼
            if validation["ai_models_loaded"] and validation["market_data_loaded"]:
                market_status = self.data_processor.get_current_market_status(
                    self.sp500_df, self.market_data_dict
                )
                predictions = self.prediction_analyzer.analyze_model_predictions(
                    self.trained_models_results, market_status.current_price
                )
                validation["ai_predictions_working"] = len(predictions) > 0
                
                # é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰ã®ç¢ºèª
                if "long_term" in predictions:
                    long_term_trend = predictions["long_term"].trend_pct
                    validation["ai_predictions_working"] = abs(long_term_trend) > 0.001
            
            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†ææ©Ÿèƒ½ã®æ¤œè¨¼
            if validation["market_data_loaded"]:
                tech_signals = self.technical_analyzer.analyze_technical_signals(self.sp500_df)
                validation["technical_analysis_working"] = (
                    tech_signals.total_buy_score + tech_signals.total_sell_score > 0
                )
            
            # ãƒ‡ãƒ¼ã‚¿å“è³ªã‚¹ã‚³ã‚¢è¨ˆç®—
            quality_score = 0.0
            if validation["market_data_loaded"]:
                quality_score += 0.3
            if validation["ai_models_loaded"]:
                quality_score += 0.3
            if validation["ai_predictions_working"]:
                quality_score += 0.2
            if validation["technical_analysis_working"]:
                quality_score += 0.2
            
            validation["data_quality_score"] = quality_score
            validation["overall_status"] = "HEALTHY" if quality_score > 0.8 else ("WARNING" if quality_score > 0.5 else "ERROR")
            
            self.logger.info(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼å®Œäº†: ã‚¹ã‚³ã‚¢={quality_score:.2f}, ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹={validation['overall_status']}")
            return validation
            
        except Exception as e:
            self.logger.error(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            validation["validation_error"] = str(e)
            validation["overall_status"] = "ERROR"
            return validation

    def _get_current_config(self) -> Dict[str, Any]:
        """ç¾åœ¨ã®è¨­å®šæƒ…å ±ã‚’å–å¾—"""
        return {
            "profile_name": self.current_profile,
            "profile_config": self.profile_config,
            "available_profiles": list(ProfileConstants.UNIFIED_PROFILES.keys()),
            "market_constants": {
                "default_sp500_price": MarketConstants.DEFAULT_SP500_PRICE,
                "vix_default": MarketConstants.VIX_DEFAULT,
                "confidence_range": f"{MarketConstants.MIN_CONFIDENCE}-{MarketConstants.MAX_CONFIDENCE}"
            }
        }

    def set_profile(self, profile_name: str) -> bool:
        """ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´"""
        if profile_name in ProfileConstants.UNIFIED_PROFILES:
            self.current_profile = profile_name
            self.profile_config = ProfileConstants.UNIFIED_PROFILES[profile_name]
            self.logger.info(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ '{profile_name}' ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚")
            return True
        else:
            self.logger.warning(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« '{profile_name}' ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚")
            return False

    def get_profile_list(self) -> List[str]:
        """åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’å–å¾—"""
        return list(ProfileConstants.UNIFIED_PROFILES.keys())

    def get_current_profile_name(self) -> str:
        """ç¾åœ¨ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—"""
        return self.current_profile

    # ============================================================================
    # äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›æ€§ï¼‰
    # ============================================================================

    def _extract_prediction_prices(self) -> Dict[str, Dict[str, Any]]:
        """å„ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ä¾¡æ ¼ã‚’æŠ½å‡ºï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›æ€§ç¶­æŒï¼‰"""
        try:
            # ç¾åœ¨ã®å¸‚å ´ä¾¡æ ¼ã‚’å–å¾—
            if not self.sp500_df.empty:
                current_price = self.sp500_df['Close'].iloc[-1]
            else:
                current_price = MarketConstants.DEFAULT_SP500_PRICE

            # æ–°ã—ã„äºˆæ¸¬ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼ã‚’ä½¿ç”¨
            predictions = self.prediction_analyzer.analyze_model_predictions(
                self.trained_models_results, current_price
            )
            
            # ãƒ¬ã‚¬ã‚·ãƒ¼å½¢å¼ã«å¤‰æ›
            prediction_prices = {}
            
            if "nextday" in predictions:
                prediction_prices['nextday'] = {
                    'price': predictions["nextday"].price,
                    'period': 'ç¿Œæ—¥'
                }
            
            if "short_term" in predictions:
                prediction_prices['short'] = {
                    'price': predictions["short_term"].price,
                    'period': '20æ—¥å¾Œ'
                }
            
            if "long_term" in predictions:
                prediction_prices['long'] = {
                    'price': predictions["long_term"].price,
                    'period': '30æ—¥å¾Œ'
                }
            
            self.logger.info(f"äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºå®Œäº†: {prediction_prices}")
            return prediction_prices
            
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _extract_long_term_prediction(self, long_pred_array) -> float:
        """é•·æœŸäºˆæ¸¬ã®å®‰å®šåŒ–å‡¦ç†ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        try:
            if isinstance(long_pred_array, (list, np.ndarray)) and len(long_pred_array) > 20:
                # æœ€å¾Œã®20%ã®æœŸé–“ã®å¹³å‡ã‚’ä½¿ç”¨ã—ã¦å®‰å®šåŒ–
                stable_period = max(5, len(long_pred_array) // 5)
                stable_pred = np.mean(long_pred_array[-stable_period:])
                original_pred = long_pred_array[-1]
                
                # å®‰å®šåŒ–ã®åŠ¹æœã‚’ãƒ­ã‚°å‡ºåŠ›
                stabilization_effect = abs(stable_pred - original_pred) / original_pred * 100 if original_pred != 0 else 0
                self.logger.debug(f"é•·æœŸäºˆæ¸¬å®‰å®šåŒ–: å…ƒå€¤={original_pred:.2f} â†’ å®‰å®šåŒ–å€¤={stable_pred:.2f} (å·®ç•°: {stabilization_effect:.1f}%)")
                
                return stable_pred
            elif len(long_pred_array) > 0:
                return long_pred_array[-1]
            else:
                self.logger.warning("é•·æœŸäºˆæ¸¬é…åˆ—ãŒç©ºã§ã™")
                return MarketConstants.DEFAULT_SP500_PRICE
                
        except Exception as e:
            self.logger.error(f"é•·æœŸäºˆæ¸¬æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return long_pred_array[-1] if len(long_pred_array) > 0 else MarketConstants.DEFAULT_SP500_PRICE

    # ============================================================================
    # ãƒ‡ãƒãƒƒã‚°ãƒ»ãƒ­ã‚°æ©Ÿèƒ½
    # ============================================================================

    def _debug_ai_predictions_detailed(self):
        """AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒ‡ãƒãƒƒã‚°ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        self.logger.info("=== AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿è©³ç´°åˆ†æ ===")
        
        for model_key, model_result in self.trained_models_results.items():
            self.logger.info(f"\n--- {model_key}ãƒ¢ãƒ‡ãƒ«è©³ç´° ---")
            
            if isinstance(model_result, dict):
                # åŸºæœ¬æƒ…å ±ã®è¡¨ç¤º
                for key, value in model_result.items():
                    if isinstance(value, list):
                        if len(value) > 0:
                            self.logger.info(f"  {key}: List[{len(value)}] - æœ€å¾Œã®3ã¤: {value[-3:]}")
                        else:
                            self.logger.info(f"  {key}: ç©ºã®ãƒªã‚¹ãƒˆ")
                    elif isinstance(value, (int, float)):
                        self.logger.info(f"  {key}: {value}")
                    elif isinstance(value, np.ndarray):
                        self.logger.info(f"  {key}: Array{value.shape} - æœ€å¾Œã®å€¤: {value.flatten()[-1] if value.size > 0 else 'N/A'}")
                    else:
                        self.logger.info(f"  {key}: {type(value)}")
                
                # äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°åˆ†æ
                if 'y_pred_original_test' in model_result and 'y_test_original_test' in model_result:
                    pred = model_result['y_pred_original_test']
                    actual = model_result['y_test_original_test']
                    
                    if isinstance(pred, list) and isinstance(actual, list) and len(pred) > 0 and len(actual) > 0:
                        self.logger.info(f"  äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿é•·: {len(pred)}, å®Ÿéš›ãƒ‡ãƒ¼ã‚¿é•·: {len(actual)}")
                        self.logger.info(f"  æœ€å¾Œã®äºˆæ¸¬å€¤: {pred[-1]}, æœ€å¾Œã®å®Ÿéš›å€¤: {actual[-1]}")
                        
                        # ç²¾åº¦ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨ˆç®—
                        if len(pred) == len(actual):
                            mae = np.mean(np.abs(np.array(pred) - np.array(actual)))
                            self.logger.info(f"  å¹³å‡çµ¶å¯¾èª¤å·®(MAE): {mae:.2f}")
                
                # æœ€æ–°äºˆæ¸¬å€¤ã®è¡¨ç¤º
                if 'latest_prediction_original' in model_result:
                    latest_pred = model_result['latest_prediction_original']
                    self.logger.info(f"  æœ€æ–°äºˆæ¸¬å€¤: {latest_pred}")
                    
                    # äºˆæ¸¬å€¤ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                    if isinstance(latest_pred, (list, np.ndarray)):
                        if len(latest_pred) > 0:
                            price_range = f"{min(latest_pred):.2f} - {max(latest_pred):.2f}"
                            self.logger.info(f"  äºˆæ¸¬ä¾¡æ ¼ç¯„å›²: {price_range}")

# ============================================================================
# ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå°‚ç”¨ã‚¯ãƒ©ã‚¹ï¼ˆæ”¹å–„ç‰ˆï¼‰
# ============================================================================

class ReportGenerator:
    """ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆï¼ˆJSONä¿å­˜ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ï¼‰"""
    
    def __init__(self, logger_manager=None):
        self.logger = self._setup_logger(logger_manager)

    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger

    def save_report_to_json(self, report_data: Dict[str, Any], filename: str):
        """JSONãƒ¬ãƒãƒ¼ãƒˆä¿å­˜ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        self.logger.info(f"åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ '{filename}' ã«ä¿å­˜è©¦è¡Œ...")
        
        try:
            # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
            save_dir = os.path.dirname(filename)
            if save_dir and not os.path.exists(save_dir):
                os.makedirs(save_dir)
            
            # ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
            cleaned_data = self._clean_data_for_json(report_data)
            
            # JSONä¿å­˜
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(cleaned_data, f, indent=2, ensure_ascii=False, default=str)
            
            self.logger.info(f"åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ '{filename}' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
            
        except IOError as e:
            self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆ '{filename}' ä¿å­˜IOã‚¨ãƒ©ãƒ¼: {e}")
        except Exception as e:
            self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆ '{filename}' ä¿å­˜ä¸­äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)

    def _clean_data_for_json(self, obj: Any) -> Any:
        """JSONä¿å­˜ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°"""
        if isinstance(obj, dict):
            return {k: self._clean_data_for_json(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._clean_data_for_json(v) for v in obj]
        elif pd.isna(obj):
            return None
        elif isinstance(obj, (np.integer, np.floating)):
            return float(obj)
        elif isinstance(obj, np.bool_):
            return bool(obj)
        elif isinstance(obj, pd.Timestamp):
            return obj.isoformat()
        elif isinstance(obj, datetime):
            return obj.isoformat()
        elif hasattr(obj, '__dict__'):  # ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ãªã©
            return self._clean_data_for_json(obj.__dict__)
        return obj

    def print_basic_report_to_console(self, report_data: Dict[str, Any]):
        """åŸºæœ¬ãƒ¬ãƒãƒ¼ãƒˆã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«è¡¨ç¤ºï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        if not report_data:
            self.logger.warning("è¡¨ç¤ºã™ã‚‹ãƒ¬ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚")
            return
        
        try:
            print("\n" + "="*10 + " ğŸ“ˆ S&P500 ç©ç«‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ†æãƒ¬ãƒãƒ¼ãƒˆ ğŸ“‰ " + "="*10)
            
            # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º
            metadata = report_data.get('metadata', {})
            print(f"åˆ†ææ—¥æ™‚: {metadata.get('generated_at', 'N/A')}")
            
            # ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±
            profile_name = metadata.get('profile', 'æœªè¨­å®š')
            profile_desc = ProfileConstants.UNIFIED_PROFILES.get(profile_name, {}).get("profile_description", "N/A")
            print(f"æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {profile_name} ({profile_desc})")
            print("-" * 60)

            # å¸‚å ´çŠ¶æ³
            market_analysis = report_data.get("market_analysis", {})
            status = market_analysis.get("current_status", {})
            print(f"â–  S&P500 ç¾çŠ¶:")
            print(f"  - æœ€æ–°ä¾¡æ ¼ ({status.get('last_price_date', 'N/A')}): {status.get('current_price', 0.0):.2f}")
            if "vix" in status:
                print(f"  - VIXæŒ‡æ•°: {status['vix']:.2f} ({status.get('vix_level', 'N/A')})")

            # AIä¾¡æ ¼äºˆæ¸¬
            predictions = market_analysis.get("ai_predictions", {})
            print("\nâ–  AIä¾¡æ ¼äºˆæ¸¬ (LSTM):")
            
            if "nextday" in predictions:
                pred = predictions["nextday"]
                price = pred.get("price", 0.0)
                trend = pred.get("trend_pct", 0.0)
                mape = pred.get("mape", 0.0)
                print(f"  - ç¿Œæ—¥äºˆæ¸¬: {price:.2f} (ãƒˆãƒ¬ãƒ³ãƒ‰: {trend:.2f}%, MAPE: {mape:.2f}%)")
            
            if "short_term" in predictions:
                pred = predictions["short_term"]
                price = pred.get("price", 0.0)
                trend = pred.get("trend_pct", 0.0)
                mape = pred.get("mape", 0.0)
                print(f"  - çŸ­æœŸäºˆæ¸¬: {price:.2f} (ãƒˆãƒ¬ãƒ³ãƒ‰: {trend:.2f}%, MAPE: {mape:.2f}%)")
            
            if "long_term" in predictions:
                pred = predictions["long_term"]
                price = pred.get("price", 0.0)
                trend = pred.get("trend_pct", 0.0)
                mape = pred.get("mape", 0.0)
                print(f"  - é•·æœŸäºˆæ¸¬: {price:.2f} (ãƒˆãƒ¬ãƒ³ãƒ‰: {trend:.2f}%, MAPE: {mape:.2f}%)")

            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚µãƒãƒªãƒ¼
            tech_signals = market_analysis.get("technical_signals", {})
            print("\nâ–  ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚µãƒãƒªãƒ¼:")
            print(f"  - MAã‚¯ãƒ­ã‚¹: {tech_signals.get('ma_cross_status', 'æƒ…å ±ãªã—')}")
            print(f"  - RSI: {tech_signals.get('rsi_signal', 'N/A')} ({tech_signals.get('rsi_current', 0):.1f})")
            
            recent_days = tech_signals.get('recent_days_for_count', 0)
            print(f"  - ç›´è¿‘{recent_days}æ—¥ã®ã‚·ã‚°ãƒŠãƒ«:")
            print(f"    è²·ã„ã‚·ã‚°ãƒŠãƒ«åˆè¨ˆ: {tech_signals.get('total_buy_score', 0)}")
            print(f"    å£²ã‚Šã‚·ã‚°ãƒŠãƒ«åˆè¨ˆ: {tech_signals.get('total_sell_score', 0)}")

            # æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹
            print("-" * 60)
            advice_section = report_data.get("investment_advice", {})
            profile_advice = advice_section.get("profile_adjusted_advice", {})
            advice_text = profile_advice.get("advice_text", advice_section.get("primary_action", "åˆ¤æ–­ææ–™ä¸è¶³"))
            print(f"â–  ç·åˆç©ç«‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹:\n  {advice_text}")
            
            # è­¦å‘Šè¡¨ç¤º
            warnings = advice_section.get("warnings", [])
            if warnings:
                print("\nâ–  æ³¨æ„äº‹é …:")
                for i, warning in enumerate(warnings[:3], 1):
                    print(f"  {i}. {warning}")
            
            print("-" * 60 + "\n")
            
        except Exception as e:
            self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)

# ============================================================================
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›æ€§ï¼‰
# ============================================================================

class MarketDataAnalyzer:
    """å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æã®ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ç¾¤ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›æ€§ç¶­æŒï¼‰"""
    
    def __init__(self, logger_manager=None):
        self.logger = self._setup_logger(logger_manager)
        self.data_processor = MarketDataProcessor(logger_manager)
    
    def _setup_logger(self, logger_manager):
        """ãƒ­ã‚¬ãƒ¼ã®å®‰å…¨ãªè¨­å®š"""
        if logger_manager:
            return logger_manager.get_logger(self.__class__.__name__)
        else:
            logger = logging.getLogger(self.__class__.__name__)
            if not logger.handlers:
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
                handler.setFormatter(formatter)
                logger.addHandler(handler)
                logger.setLevel(logging.INFO)
            return logger
    
    @staticmethod
    def get_nested_value(data: dict, keys: list, default=None):
        """ãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã‹ã‚‰å€¤ã‚’å®‰å…¨ã«å–å¾—"""
        for key in keys:
            if isinstance(data, dict) and key in data:
                data = data[key]
            else:
                return default
        return data
    
    def find_last_signal_date(self, df: pd.DataFrame, signal_column_name: str) -> Optional[pd.Timestamp]:
        """æŒ‡å®šã•ã‚ŒãŸã‚·ã‚°ãƒŠãƒ«åˆ—ã®æœ€å¾Œã®ç™ºç”Ÿæ—¥ã‚’æ¤œç´¢"""
        if signal_column_name not in df.columns or df[signal_column_name].dtype != 'bool':
            self.logger.debug(f"ã‚·ã‚°ãƒŠãƒ«åˆ— '{signal_column_name}' ä¸åœ¨ã¾ãŸã¯éboolå‹ã€‚")
            return None
        
        try:
            true_signals = df.loc[df[signal_column_name]]
            return pd.Timestamp(true_signals.index.max()) if not true_signals.empty else None
        except Exception as e:
            self.logger.warning(f"'{signal_column_name}' æœ€çµ‚ã‚·ã‚°ãƒŠãƒ«æ—¥æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return None
    
    def is_date_within_recent_days(self, latest_market_date: pd.Timestamp,
                                   target_event_date: Optional[pd.Timestamp], recent_days_threshold: int) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ãŒæœ€è¿‘ã®é–¾å€¤æ—¥æ•°ä»¥å†…ã‹ã‚’åˆ¤å®š"""
        if target_event_date is None:
            return False
        if not (isinstance(latest_market_date, pd.Timestamp) and isinstance(target_event_date, pd.Timestamp)):
            self.logger.warning("is_date_within_recent_days: æ—¥ä»˜ãŒTimestampå‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚")
            return False
        return (latest_market_date - target_event_date).days <= recent_days_threshold
    
    def calculate_trend_percentage(self, prediction_array: Any, period_name: str = "æœŸé–“", 
                                  current_market_price: Optional[float] = None) -> float:
        """äºˆæ¸¬é…åˆ—ã‹ã‚‰ç¾åœ¨ä¾¡æ ¼ã‚’åŸºæº–ã¨ã—ãŸãƒˆãƒ¬ãƒ³ãƒ‰%ã‚’è¨ˆç®—"""
        try:
            if isinstance(prediction_array, pd.Series):
                values = prediction_array.dropna().values
            elif isinstance(prediction_array, np.ndarray):
                values = prediction_array.flatten()
            elif isinstance(prediction_array, list):
                values = np.array([v for v in prediction_array if v is not None and not np.isnan(v)])
            else:
                self.logger.warning(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: æœªå¯¾å¿œå‹ {type(prediction_array)}")
                return 0.0
            
            if len(values) < 1:
                self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: ãƒ‡ãƒ¼ã‚¿ç‚¹ä¸è¶³ ({len(values)})")
                return 0.0
            
            if current_market_price is not None and current_market_price > 0:
                base_price = current_market_price
            else:
                base_price = values[0]
            
            end_price = values[-1]
            
            if base_price <= 0 or np.isnan(base_price) or np.isnan(end_price):
                self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: ç„¡åŠ¹ãªä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ (base: {base_price}, end: {end_price})")
                return 0.0
            
            trend_pct = ((end_price - base_price) / base_price) * 100
            self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: {base_price:.2f} â†’ {end_price:.2f} = {trend_pct:.2f}%")
            return float(trend_pct)
            
        except Exception as e:
            self.logger.warning(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return 0.0
    
    def get_sp500_dataframe(self, market_data_dict: Dict[str, Dict[str, Any]]) -> Optional[pd.DataFrame]:
        """å¸‚å ´ãƒ‡ãƒ¼ã‚¿è¾æ›¸ã‹ã‚‰S&P500 DataFrameã‚’å–å¾—ï¼ˆæ–°ã—ã„ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã«å§”è­²ï¼‰"""
        return self.data_processor.get_sp500_dataframe(market_data_dict)

# ============================================================================
# ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚¯ãƒ©ã‚¹
# ============================================================================

class MarketAnalysisFactory:
    """å¸‚å ´åˆ†æã‚·ã‚¹ãƒ†ãƒ ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚¯ãƒ©ã‚¹"""
    
    @staticmethod
    def create_investment_advisor(market_data_dict: Dict, trained_models_results: Dict, 
                                logger_manager=None, initial_profile_name: str = "natural") -> InvestmentAdvisor:
        """æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã®ä½œæˆ"""
        return InvestmentAdvisor(
            market_data_dict=market_data_dict,
            trained_models_results=trained_models_results,
            logger_manager=logger_manager,
            initial_profile_name=initial_profile_name
        )
    
    @staticmethod
    def create_config_loader(config_path: str = "advisor_config.json", 
                           logger_manager=None) -> AdvisorConfigLoader:
        """è¨­å®šãƒ­ãƒ¼ãƒ€ãƒ¼ã®ä½œæˆ"""
        return AdvisorConfigLoader(
            config_path=config_path,
            logger_manager=logger_manager
        )
    
    @staticmethod
    def create_report_generator(logger_manager=None) -> ReportGenerator:
        """ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå™¨ã®ä½œæˆ"""
        return ReportGenerator(logger_manager=logger_manager)

# ============================================================================
# ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œç”¨ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
# ============================================================================

def main_example():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œä¾‹ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰"""
    try:
        # ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿéš›ã®ä½¿ç”¨æ™‚ã¯å®Ÿãƒ‡ãƒ¼ã‚¿ã«ç½®ãæ›ãˆï¼‰
        sample_market_data = {
            "^GSPC": {
                "df": pd.DataFrame({
                    'Close': [5900, 5950, 6000, 6050, 6000],
                    'Volume': [1000000, 1100000, 1200000, 1300000, 1250000],
                    'VIX': [20, 19, 18, 22, 21]
                }, index=pd.date_range('2025-01-01', periods=5))
            }
        }
        
        sample_model_results = {
            "nextday": {
                "latest_prediction_original": [6025.0],
                "mape_test": 2.5
            },
            "short": {
                "latest_prediction_original": [5980.0, 6010.0, 6040.0],
                "mape_test": 3.8
            },
            "long": {
                "latest_prediction_original": [5950.0, 5980.0, 6020.0, 6050.0, 6030.0],
                "mape_test": 4.2
            }
        }
        
        # ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ä½œæˆ
        advisor = MarketAnalysisFactory.create_investment_advisor(
            market_data_dict=sample_market_data,
            trained_models_results=sample_model_results,
            initial_profile_name="natural"
        )
        
        # ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼
        validation_result = advisor.validate_system()
        print(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼çµæœ: {validation_result['overall_status']}")
        
        # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        success = advisor.generate_investment_report(
            save_to_json=True,
            print_to_console=True
        )
        
        if success:
            print("\nğŸ‰ ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œ æ­£å¸¸å®Œäº† ğŸ‰")
        else:
            print("\nâŒ ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ âŒ")
            
    except Exception as e:
        print(f"ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")

if __name__ == "__main__":
    main_example()

# ============================================================================
# æœ€çµ‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›æ€§ç¶­æŒï¼‰
# ============================================================================

# ãƒ¬ã‚¬ã‚·ãƒ¼ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ã®ãŸã‚ã€å¾“æ¥ã®åå‰ã§ã‚‚ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
UNIFIED_PROFILES = ProfileConstants.UNIFIED_PROFILES
DEFAULT_SP500_PRICE = MarketConstants.DEFAULT_SP500_PRICE
VIX_DEFAULT = MarketConstants.VIX_DEFAULT
RSI_OVERSOLD = MarketConstants.RSI_OVERSOLD
RSI_OVERBOUGHT = MarketConstants.RSI_OVERBOUGHT

# ä¸»è¦ã‚¯ãƒ©ã‚¹ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
__all__ = [
    'InvestmentAdvisor',
    'AdvisorConfigLoader', 
    'MarketDataAnalyzer',
    'ReportGenerator',
    'MarketDataProcessor',
    'PredictionAnalyzer',
    'TechnicalAnalyzer',
    'MarketAnalysisFactory',
    'MarketConstants',
    'ProfileConstants',
    'PredictionResult',
    'MarketStatus',
    'TechnicalSignals',
    'MarketAssessment',
    'ConfidenceCalculator',
    'PriceValidator',
    'TrendJudge'
]


class MarketPredictionSystem:
    """é‡‘èå¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹"""

    def __init__(
        self, config_file: str = "config.json", advisor_config_file: str = "advisor_config.json",
        logger_manager: LoggerManager = APP_LOGGER_MANAGER, # å¤–éƒ¨ã‹ã‚‰LoggerManagerã‚’æ³¨å…¥å¯èƒ½ã«
        reuse_hyperparams_on_init: bool = False,
        data_source_type: str = "api" # "api" or "csv"
    ):
        self.logger_manager = logger_manager
        self.logger = self.logger_manager.get_logger(self.__class__.__name__)
        self.logger.info(f"ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹ã€‚ãƒ¡ã‚¤ãƒ³è¨­å®š: {config_file}, ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼è¨­å®š: {advisor_config_file}, ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹: {data_source_type}")

        self.config = Config(config_file, logger_manager=self.logger_manager)

        # HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ (DataFetcher APIç”¨)
        self.http_session: Optional[Any] = None # CurlSessionã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        if CurlSession: # ã‚°ãƒ­ãƒ¼ãƒãƒ«CurlSessionãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°
            try:
                if CurlSession.__module__.startswith("curl_cffi"):
                    self.http_session = CurlSession(impersonate="chrome110")
                    self.logger.info("HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ã« curl_cffi.requests.Session ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
                else:
                    self.http_session = CurlSession()
                    self.logger.info("HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ã« requests.Session ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
            except Exception as e:
                self.logger.warning(f"ã‚°ãƒ­ãƒ¼ãƒãƒ«CurlSessionã‹ã‚‰ã®HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã«å¤±æ•—: {e}")
        else:
            self.logger.warning("CurlSessionã‚¨ã‚¤ãƒªã‚¢ã‚¹ãŒæœªå®šç¾©ã€‚APIãƒ™ãƒ¼ã‚¹ã®DataFetcherã¯HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ãªã—ã§å‹•ä½œã—ã¾ã™ã€‚")

        # ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ£ãƒ¼ã®é¸æŠ
        self.data_source_type = data_source_type.lower()
        if self.data_source_type == "csv":
            self.data_fetcher: Union[CSVDataFetcher, DataFetcher] = CSVDataFetcher(self.config, self.logger_manager)
            self.logger.info("CSVDataFetcher ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
        elif self.data_source_type == "api":
            self.data_fetcher = DataFetcher(self.config, self.logger_manager, session=self.http_session)
            self.logger.info("DataFetcher (APIãƒ™ãƒ¼ã‚¹) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
        else:
            self.logger.error(f"ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—: {data_source_type}ã€‚'api' ã¾ãŸã¯ 'csv' ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚APIã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¾ã™ã€‚")
            self.data_fetcher = DataFetcher(self.config, self.logger_manager, session=self.http_session) # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

        self.feature_engineering = FeatureEngineering(self.config, self.logger_manager)
        self.lstm_model = LSTMModel(self.config, self.logger_manager)
        self.visualizer = MarketVisualizer(self.config, self.logger_manager)
        self.advisor_config_file = advisor_config_file # InvestmentAdvisoråˆæœŸåŒ–æ™‚ã«æ¸¡ã™

        if reuse_hyperparams_on_init:
            self.lstm_model.load_best_params()

        self.market_data_store: Dict[str, Any] = {}
        self.trained_models_store: Dict[str, Any] = {}


    def run(
        self, force_hyperparam_optimization: bool = False,
        optimization_n_trials: Optional[int] = None,
        generate_report_profile: str = "natural"
    ) -> bool:
        self.logger.info(f"ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œé–‹å§‹ã€‚æœ€é©åŒ–å¼·åˆ¶:{force_hyperparam_optimization}, Optunaè©¦è¡Œ:{optimization_n_trials or 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ'}, ãƒ¬ãƒãƒ¼ãƒˆãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«:{generate_report_profile}")
        run_start_time = datetime.now()
        overall_success = False
        try:
            # 1. ãƒ‡ãƒ¼ã‚¿å–å¾—
            self.logger.info("--- ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ ---")
            self.market_data_store = self.data_fetcher.fetch_all_indexes()
            if not self.market_data_store or "^GSPC" not in self.market_data_store or self.market_data_store["^GSPC"]["df"].empty:
                self.logger.critical("ä¸»è¦å¸‚å ´ãƒ‡ãƒ¼ã‚¿(S&P500)å–å¾—å¤±æ•—ã€‚ã‚·ã‚¹ãƒ†ãƒ ç¶šè¡Œä¸å¯ã€‚")
                return False
            self.logger.info("ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 2. ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°
            self.logger.info("--- ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ ---")
            self.market_data_store = self.feature_engineering.add_technical_indicators(self.market_data_store)
            self.logger.info("ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 3. ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ– (S&P500å¯¾è±¡)
            if force_hyperparam_optimization or (not self.lstm_model.best_params and self.lstm_model.load_best_params() is False) : # ãƒ­ãƒ¼ãƒ‰è©¦è¡Œã—ã¦ãƒ€ãƒ¡ãªã‚‰
                self.logger.info("--- LSTMãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
                if "^GSPC" in self.market_data_store and not self.market_data_store["^GSPC"]["df"].empty:
                    self.lstm_model.optimize_hyperparameters(self.market_data_store, target_ticker="^GSPC", n_trials=optimization_n_trials)
                else: self.logger.warning("S&P500ãƒ‡ãƒ¼ã‚¿ä¸ååˆ†ã§æœ€é©åŒ–ã‚¹ã‚­ãƒƒãƒ—ã€‚")
                self.logger.info("ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")
            else: self.logger.info("æ—¢å­˜ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½¿ç”¨ã¾ãŸã¯æœ€é©åŒ–è¦æ±‚ãªã—ã€‚")

            # 4. LSTMãƒ¢ãƒ‡ãƒ«å­¦ç¿’ (S&P500å¯¾è±¡)
            self.logger.info("--- LSTMãƒ¢ãƒ‡ãƒ«å­¦ç¿’ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
            if "^GSPC" in self.market_data_store and not self.market_data_store["^GSPC"]["df"].empty:
                if not self.lstm_model.best_params: self.lstm_model.load_best_params() # å†åº¦ãƒ­ãƒ¼ãƒ‰è©¦è¡Œ
                self.trained_models_store = self.lstm_model.train_models_for_sp500(self.market_data_store)
            else: self.logger.error("S&P500ãƒ‡ãƒ¼ã‚¿ä¸ååˆ†ã§LSTMå­¦ç¿’ã‚¹ã‚­ãƒƒãƒ—ã€‚")
            self.logger.info("LSTMãƒ¢ãƒ‡ãƒ«å­¦ç¿’ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 5. å¯è¦–åŒ– (S&P500å¯¾è±¡)
            self.logger.info("--- å¯è¦–åŒ–ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
            if "^GSPC" in self.market_data_store and self.trained_models_store:
                graph_path = self.visualizer.plot_predictions_for_sp500(self.market_data_store, self.trained_models_store)
                if graph_path: self.logger.info(f"åˆ†æã‚°ãƒ©ãƒ•ã‚’ {graph_path} ã«ä¿å­˜ã€‚")
                else: self.logger.warning("ã‚°ãƒ©ãƒ•ç”Ÿæˆ/ä¿å­˜å¤±æ•—ã€‚")
            else: self.logger.warning("S&P500ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯å­¦ç¿’æ¸ˆãƒ¢ãƒ‡ãƒ«ãªã—ã€‚å¯è¦–åŒ–ã‚¹ã‚­ãƒƒãƒ—ã€‚")
            self.logger.info("å¯è¦–åŒ–ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 6. æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆ (S&P500å¯¾è±¡)
            self.logger.info("--- æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
            if "^GSPC" in self.market_data_store and self.trained_models_store:
                advisor = InvestmentAdvisor(
                    market_data_dict=self.market_data_store,      # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§æ˜ç¤ºçš„ã«
                    trained_models_results=self.trained_models_store, # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§æ˜ç¤ºçš„ã«
                    logger_manager=self.logger_manager,        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§æ˜ç¤ºçš„ã«
                    initial_profile_name=generate_report_profile # advisor_config_file ã‚’å‰Šé™¤ã—ã€profileã‚’æ¸¡ã™
                )
                if not advisor.generate_investment_report(save_to_json=True, print_to_console=True): # ä¾‹: ãƒ¬ãƒãƒ¼ãƒˆã‚‚ç”Ÿæˆ
                    self.logger.warning("æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå¤±æ•—ã€‚")
            else: self.logger.warning("S&P500ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯å­¦ç¿’æ¸ˆãƒ¢ãƒ‡ãƒ«ãªã—ã€‚æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¹ã‚­ãƒƒãƒ—ã€‚")
            self.logger.info("æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")
            overall_success = True

        except KeyboardInterrupt:
            self.logger.warning("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚Šå‡¦ç†ãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸã€‚")
        except Exception as e:
            self.logger.critical(f"ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œä¸­ã«è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
        finally:
            self.logger_manager.save_performance_log() # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ­ã‚°ä¿å­˜
            duration_sec = (datetime.now() - run_start_time).total_seconds()
            self.logger.info(f"å¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ å…¨å‡¦ç†çµ‚äº†ã€‚æ‰€è¦æ™‚é–“: {duration_sec:.2f}ç§’ã€‚æˆåŠŸ: {overall_success}")
        return overall_success


# --- Jupyter Notebook / ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œã®ãŸã‚ã®ãƒ¡ã‚¤ãƒ³å‡¦ç†éƒ¨åˆ† ---
if __name__ == "__main__":
    # ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªLoggerManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ç”¨
    main_logger = APP_LOGGER_MANAGER.get_logger("MainExecution")
    main_logger.info("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œé–‹å§‹ã€‚")

    # --- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ (å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´) ---
    main_config_path = "config.json"
    advisor_config_path = "advisor_config.json"
    # config.jsonã®ã‚µãƒ³ãƒ—ãƒ« (ä¸Šè¨˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å‚è€ƒã«ä½œæˆã—ã¦ãã ã•ã„)
    # advisor_config.jsonã®ã‚µãƒ³ãƒ—ãƒ« (ä¸Šè¨˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å‚è€ƒã«ä½œæˆã—ã¦ãã ã•ã„)

    # Jupyter Notebookç’°å¢ƒã‹ã©ã†ã‹ã§UIã‚’åˆ†å²
    is_jupyter = False
    try:
        # Jupyterç’°å¢ƒã§ã®ã¿æˆåŠŸã™ã‚‹ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        from IPython import get_ipython
        if get_ipython() is not None and 'IPKernelApp' in get_ipython().config:
            is_jupyter = True
            import ipywidgets as widgets
            from IPython.display import display, clear_output
            main_logger.info("Jupyter Notebookç’°å¢ƒã‚’æ¤œå‡ºã€‚ipywidgets UIã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
    except ImportError:
        main_logger.info("Jupyter Notebookç’°å¢ƒã§ã¯ãªã„ã‹ã€ipywidgetsãŒã‚ã‚Šã¾ã›ã‚“ã€‚CUIãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œã—ã¾ã™ã€‚")


    if is_jupyter:
        # --- Jupyter UI ---
        data_source_selector_ui = widgets.ToggleButtons(
            options=[('API (yfinance)', 'api'), ('ãƒ­ãƒ¼ã‚«ãƒ«CSV', 'csv')], description='ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹:', value='api',
            style={'button_width': 'auto'}, tooltips=['yfinanceçµŒç”±ã§æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—', 'äº‹å‰ã«ç”¨æ„ã—ãŸCSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨']
        )
        hyperparam_mode_selector_ui = widgets.ToggleButtons(
            options=[('æ–°è¦æœ€é©åŒ–', 'optimize'), ('ä¿å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æµç”¨', 'reuse')], description='ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:', value='reuse',
            style={'button_width': 'auto'}
        )
        optuna_trials_input_ui = widgets.IntText(
            value=APP_LOGGER_MANAGER.get_logger("UI_Config").info("Optunaè©¦è¡Œå›æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯Configã‹ã‚‰å–å¾—ã‚’æ¨å¥¨") or 5, # configã‹ã‚‰å–å¾—ã—ãŸã„
            description='Optunaè©¦è¡Œå›æ•°:', disabled=(hyperparam_mode_selector_ui.value == 'reuse')
        )
        def handle_hyperparam_mode_change(change): optuna_trials_input_ui.disabled = (change.new == 'reuse')
        hyperparam_mode_selector_ui.observe(handle_hyperparam_mode_change, names='value')

        # ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¯AdvisorConfigLoaderã‹ã‚‰å‹•çš„ã«å–å¾—ã—ãŸã„
        # ã“ã“ã§ã¯ä»®ã®ãƒªã‚¹ãƒˆã‚’ä½¿ç”¨ã€‚ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œæ™‚ã«AdvisorConfigLoaderãŒåˆæœŸåŒ–ã•ã‚Œã‚‹ã®ã§ã€ãã®æ™‚ç‚¹ã§å–å¾—ã™ã‚‹ã®ãŒç†æƒ³
        temp_advisor_loader = AdvisorConfigLoader(advisor_config_path, APP_LOGGER_MANAGER)
        profile_options_ui = [(p.capitalize(), p) for p in temp_advisor_loader.get_profile_list()]
        if not profile_options_ui: profile_options_ui = [('Natural', 'natural')] # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

        advisor_profile_selector_ui = widgets.Dropdown(
            options=profile_options_ui, value=profile_options_ui[0][1] if profile_options_ui else 'natural',
            description='æŠ•è³‡åˆ¤æ–­ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«:', style={'description_width': 'initial'}
        )
        run_button_ui = widgets.Button(description='å¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œ', button_style='success', icon='cogs')
        output_area_ui = widgets.Output()

        display(data_source_selector_ui, hyperparam_mode_selector_ui, optuna_trials_input_ui, advisor_profile_selector_ui, run_button_ui, output_area_ui)

        def on_run_button_clicked_ui(b):
            with output_area_ui:
                clear_output(wait=True)
                main_logger.info("--- UIã‹ã‚‰ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œé–‹å§‹ ---")
                data_src = data_source_selector_ui.value
                force_opt = (hyperparam_mode_selector_ui.value == 'optimize')
                opt_trials = optuna_trials_input_ui.value if force_opt else None
                report_prof = advisor_profile_selector_ui.value

                system = MarketPredictionSystem(
                    main_config_path, advisor_config_path, APP_LOGGER_MANAGER,
                    reuse_hyperparams_on_init=(not force_opt), data_source_type=data_src
                )
                success = system.run(force_opt, opt_trials, report_prof)
                print(f"\nğŸ‰ ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œ {'æ­£å¸¸å®Œäº†' if success else 'ã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ'} ğŸ‰" if success else "\nğŸ’¥ ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ ğŸ’¥")
        run_button_ui.on_click(on_run_button_clicked_ui)

    else:
        # --- CUIãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ ---
        print("="*30 + "\né‡‘èå¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ  (CUIãƒ¢ãƒ¼ãƒ‰)\n" + "="*30)
        ds_input = input("ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’é¸æŠ [api, csv] (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: api): ").strip().lower() or "api"
        mode_input = input("ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠ [optimize, reuse] (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: reuse): ").strip().lower() or "reuse"
        force_opt_cui = (mode_input == "optimize")
        opt_trials_cui_val = None
        if force_opt_cui:
            try: opt_trials_cui_val = int(input("Optunaè©¦è¡Œå›æ•°ã‚’å…¥åŠ› (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 5): ").strip() or "5")
            except ValueError: opt_trials_cui_val = 5

        # ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« (CUI)
        temp_advisor_loader_cui = AdvisorConfigLoader(advisor_config_path, APP_LOGGER_MANAGER)
        profiles_cui = temp_advisor_loader_cui.get_profile_list()
        profile_prompt = f"æŠ•è³‡åˆ¤æ–­ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ [{', '.join(profiles_cui)}] (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: {profiles_cui[0] if profiles_cui else 'natural'}): "
        profile_input_cui = input(profile_prompt).strip().lower() or (profiles_cui[0] if profiles_cui else 'natural')
        if profile_input_cui not in profiles_cui and profiles_cui : profile_input_cui = profiles_cui[0] # ä¸æ­£å…¥åŠ›æ™‚ã¯å…ˆé ­

        system_cui = MarketPredictionSystem(
            main_config_path, advisor_config_path, APP_LOGGER_MANAGER,
            reuse_hyperparams_on_init=(not force_opt_cui), data_source_type=ds_input
        )
        system_cui.run(force_opt_cui, opt_trials_cui_val, profile_input_cui)

    main_logger.info("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œçµ‚äº†ã€‚")
