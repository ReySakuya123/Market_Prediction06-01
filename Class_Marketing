
import os
import json
import numpy as np
import pandas as pd
from typing import Dict, Any, Optional, List, Union, Tuple # Union, Tuple ã‚’è¿½åŠ 
from datetime import datetime
from dataclasses import dataclass

# çµ±ä¸€ã•ã‚ŒãŸãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å®šç¾© (ä¿®æ­£1)
UNIFIED_PROFILES = {
    "natural": {
        "buy_threshold": 2, "sell_threshold": 2, "vix_threshold": 25,
        "confidence_threshold": 0.6, "ai_weight": 2.0,
        "short_trend_threshold_pct": 0.5, "error_accept_threshold_pct": 8.0,
        "profile_description": "æ¨™æº–çš„ãªãƒãƒ©ãƒ³ã‚¹å‹ã€‚åŸºæœ¬é–¾å€¤ã§ã‚·ã‚°ãƒŠãƒ«åˆ¤å®šã€‚" # è¿½è¨˜: èª¬æ˜ã‚‚çµ±ä¸€ç®¡ç†ã¸
    },
    "aggressive": {
        "buy_threshold": 1, "sell_threshold": 3, "vix_threshold": 30,
        "confidence_threshold": 0.4, "ai_weight": 1.5,
        "short_trend_threshold_pct": 0.2, "error_accept_threshold_pct": 10.0,
        "profile_description": "ç©æ¥µå‹ã€‚è²·ã„é–¾å€¤ä½ã‚ã€VIXè¨±å®¹é«˜ã‚ã€‚" # è¿½è¨˜
    },
    "conservative": {  # passive â†’ conservative ã«çµ±ä¸€ (ä¿®æ­£2)
        "buy_threshold": 3, "sell_threshold": 1, "vix_threshold": 20,
        "confidence_threshold": 0.8, "ai_weight": 3.0,
        "short_trend_threshold_pct": 1.0, "error_accept_threshold_pct": 6.0,
        "profile_description": "æ…é‡å‹ã€‚è²·ã„é–¾å€¤é«˜ã‚ã€VIXè¨±å®¹ä½ã‚ã€‚" # è¿½è¨˜
    }
}

DEFAULT_SP500_PRICE = 5900  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤çµ±ä¸€ (ä¿®æ­£1, ä¿®æ­£6)
VIX_DEFAULT = 20.0 # (ä¿®æ­£1)
RSI_OVERSOLD = 30 # (ä¿®æ­£1)
RSI_OVERBOUGHT = 70 # (ä¿®æ­£1)


class AdvisorConfigLoader:
    """æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ç”¨è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ãƒ»ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    DEFAULT_ADVISOR_CONFIG = {
        "report_filename_template": "market_analysis_report_{profile}.json",
        "profiles": UNIFIED_PROFILES, # (ä¿®æ­£2) ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šçµ±ä¸€
        "technical_analysis_settings": {
            "buy_signal_columns": ["golden_cross", "RSI_buy_signal", "MACD_buy_signal", "BB_buy_signal"],
            "sell_signal_columns": ["death_cross", "RSI_sell_signal", "MACD_sell_signal", "BB_sell_signal"],
            "recent_days_for_signal_count": 5,
            "ma_cross_signal_recency_days": 10
        },
    }

    def __init__(self, config_path: str = "advisor_config.json", logger_manager: Optional[LoggerManager] = None):
        self.logger = (logger_manager or APP_LOGGER_MANAGER).get_logger(self.__class__.__name__)
        self.config_path = config_path
        
        # Configã‚¯ãƒ©ã‚¹ä¾å­˜å‰Šé™¤ (ä¿®æ­£3)
        self.config_data = self._load_config_safe(config_path)
        self.config_data = self._deep_update(self.DEFAULT_ADVISOR_CONFIG.copy(), self.config_data)

        self.current_profile_name = "natural" # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        self.set_profile(self.current_profile_name) # set_profileå†…ã§UNIFIED_PROFILESãŒä½¿ã‚ã‚Œã‚‹
        self.logger.info(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼è¨­å®šã‚’ '{config_path}' ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã€‚ç¾åœ¨ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile_name}")

    def _load_config_safe(self, config_path: str) -> Dict[str, Any]: # (ä¿®æ­£3)
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å®‰å…¨ãªèª­ã¿è¾¼ã¿"""
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                self.logger.warning(f"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ« '{config_path}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
                return {}
        except Exception as e:
            self.logger.error(f"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _deep_update(self, base_dict: Dict, update_dict: Dict) -> Dict: # (ä¿®æ­£3)
        """è¾æ›¸ã®æ·±ã„ãƒãƒ¼ã‚¸"""
        for key, value in update_dict.items():
            if isinstance(value, dict) and key in base_dict and isinstance(base_dict[key], dict):
                base_dict[key] = self._deep_update(base_dict[key], value)
            else:
                base_dict[key] = value
        return base_dict

    def set_profile(self, profile_name: str) -> bool:
        # profiles ã¯ UNIFIED_PROFILES ã‚’ç›´æ¥å‚ç…§ã™ã‚‹å½¢ã«å¤‰æ›´ (config_dataçµŒç”±ã§ã¯ãªã)
        if profile_name in UNIFIED_PROFILES:
            self.current_profile_name = profile_name
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ '{profile_name}' ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚")
            return True
        else:
            self.logger.warning(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« '{profile_name}' ã¯è¨­å®šã«å­˜åœ¨ã—ã¾ã›ã‚“ã€‚'{self.current_profile_name}' ã‚’ç¶­æŒã—ã¾ã™ã€‚")
            return False

    def get_profile_list(self) -> List[str]:
        return list(UNIFIED_PROFILES.keys())

    def get_current_profile_config(self) -> Dict[str, Any]:
        return UNIFIED_PROFILES.get(self.current_profile_name, UNIFIED_PROFILES["natural"])

    def get_profile_description(self) -> str:
        # UNIFIED_PROFILES ã‹ã‚‰ç›´æ¥å–å¾—ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
        profile_conf = self.get_current_profile_config()
        return profile_conf.get("profile_description", "èª¬æ˜ãªã—")

    def get_config_value(self, key_path: str, default: Optional[Any] = None) -> Any:
        keys = key_path.split('.')
        # 1. ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰è¨­å®š (UNIFIED_PROFILESã‹ã‚‰)
        val = self.get_current_profile_config()
        for key in keys:
            if isinstance(val, dict) and key in val:
                val = val[key]
            else:
                val = None
                break
        if val is not None:
            return val
        
        # 2. å…±é€šè¨­å®š (self.config_data ã‹ã‚‰ã€‚ã“ã“ã«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸè¨­å®šã‚„DEFAULT_ADVISOR_CONFIGã®profilesä»¥å¤–ã®éƒ¨åˆ†ãŒå…¥ã‚‹)
        val_common = self.config_data
        for key in keys:
            if isinstance(val_common, dict) and key in val_common:
                val_common = val_common[key]
            else:
                return default # å…±é€šã«ã‚‚ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return val_common


class MarketDataAnalyzer:
    """å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æã®ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ç¾¤"""
    
    def __init__(self, logger_manager: Optional[LoggerManager] = None):
        self.logger = (logger_manager or APP_LOGGER_MANAGER).get_logger(self.__class__.__name__)
    
    @staticmethod
    def get_nested_value(data: dict, keys: list, default=None):
        """ãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã‹ã‚‰å€¤ã‚’å®‰å…¨ã«å–å¾—"""
        for key in keys:
            if isinstance(data, dict) and key in data:
                data = data[key]
            else:
                return default
        return data
    
    def find_last_signal_date(self, df: pd.DataFrame, signal_column_name: str) -> Optional[pd.Timestamp]:
        """æŒ‡å®šã•ã‚ŒãŸã‚·ã‚°ãƒŠãƒ«åˆ—ã®æœ€å¾Œã®ç™ºç”Ÿæ—¥ã‚’æ¤œç´¢"""
        if signal_column_name not in df.columns or df[signal_column_name].dtype != 'bool':
            self.logger.debug(f"ã‚·ã‚°ãƒŠãƒ«åˆ— '{signal_column_name}' ä¸åœ¨ã¾ãŸã¯éboolå‹ã€‚")
            return None
        try:
            true_signals = df.loc[df[signal_column_name]]
            return pd.Timestamp(true_signals.index.max()) if not true_signals.empty else None
        except Exception as e:
            self.logger.warning(f"'{signal_column_name}' æœ€çµ‚ã‚·ã‚°ãƒŠãƒ«æ—¥æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return None
    
    def is_date_within_recent_days(self, latest_market_date: pd.Timestamp,
                                   target_event_date: Optional[pd.Timestamp], recent_days_threshold: int) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ãŒæœ€è¿‘ã®é–¾å€¤æ—¥æ•°ä»¥å†…ã‹ã‚’åˆ¤å®š"""
        if target_event_date is None:
            return False
        if not (isinstance(latest_market_date, pd.Timestamp) and isinstance(target_event_date, pd.Timestamp)):
            self.logger.warning("is_date_within_recent_days: æ—¥ä»˜ãŒTimestampå‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚")
            return False
        return (latest_market_date - target_event_date).days <= recent_days_threshold
    
    def calculate_trend_percentage(self, prediction_array: Any, period_name: str = "æœŸé–“", 
                                  current_market_price: Optional[float] = None) -> float:
        """
        äºˆæ¸¬é…åˆ—ã‹ã‚‰ç¾åœ¨ä¾¡æ ¼ã‚’åŸºæº–ã¨ã—ãŸãƒˆãƒ¬ãƒ³ãƒ‰%ã‚’è¨ˆç®—
        """
        try:
            if isinstance(prediction_array, pd.Series):
                values = prediction_array.dropna().values
            elif isinstance(prediction_array, np.ndarray):
                values = prediction_array.flatten()
            elif isinstance(prediction_array, list):
                values = np.array([v for v in prediction_array if v is not None and not np.isnan(v)])
            else:
                self.logger.warning(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: æœªå¯¾å¿œå‹ {type(prediction_array)}")
                return 0.0
            
            if len(values) < 1:
                self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: ãƒ‡ãƒ¼ã‚¿ç‚¹ä¸è¶³ ({len(values)})")
                return 0.0
            
            if current_market_price is not None and current_market_price > 0:
                base_price = current_market_price
            else:
                base_price = values[0]
            
            end_price = values[-1]
            
            if base_price <= 0 or np.isnan(base_price) or np.isnan(end_price):
                self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: ç„¡åŠ¹ãªä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ (base: {base_price}, end: {end_price})")
                return 0.0
            
            trend_pct = ((end_price - base_price) / base_price) * 100
            self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: {base_price:.2f} â†’ {end_price:.2f} = {trend_pct:.2f}%")
            return float(trend_pct)
            
        except Exception as e:
            self.logger.warning(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return 0.0
    
    def get_sp500_dataframe(self, market_data_dict: Dict[str, Dict[str, Any]]) -> Optional[pd.DataFrame]:
        """å¸‚å ´ãƒ‡ãƒ¼ã‚¿è¾æ›¸ã‹ã‚‰S&P500 DataFrameã‚’å–å¾—"""
        sp500_entry = market_data_dict.get("^GSPC")
        if not sp500_entry or "df" not in sp500_entry or sp500_entry["df"].empty:
            self.logger.error("S&P500 DataFrameãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ç©ºã§ã™ã€‚")
            return None
        return sp500_entry["df"]

class ReportGenerator:
    """ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆï¼ˆJSONä¿å­˜ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ï¼‰"""
    def __init__(self, logger_manager: Optional[LoggerManager] = None):
        self.logger = (logger_manager or APP_LOGGER_MANAGER).get_logger(self.__class__.__name__)

    def save_report_to_json(self, report_data: Dict[str, Any], filename: str):
        self.logger.info(f"åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ '{filename}' ã«ä¿å­˜è©¦è¡Œ...")
        try:
            save_dir = os.path.dirname(filename)
            if save_dir and not os.path.exists(save_dir): os.makedirs(save_dir)
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False, default=str)
            self.logger.info(f"åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ '{filename}' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
        except IOError as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆ '{filename}' ä¿å­˜IOã‚¨ãƒ©ãƒ¼: {e}")
        except Exception as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆ '{filename}' ä¿å­˜ä¸­äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)

    def print_basic_report_to_console(self, report_data: Dict[str, Any]):
        if not report_data: self.logger.warning("è¡¨ç¤ºã™ã‚‹ãƒ¬ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚"); return
        try:
            print("\n" + "="*10 + " ğŸ“ˆ S&P500 ç©ç«‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ†æãƒ¬ãƒãƒ¼ãƒˆ ğŸ“‰ " + "="*10)
            print(f"åˆ†ææ—¥æ™‚: {report_data.get('analysis_datetime', 'N/A')}")
            
            # ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«åã¯ InvestmentAdvisor ã‹ã‚‰å–å¾—ã™ã‚‹ report_data["metadata"]["profile"] ã‚’å‚ç…§ã™ã‚‹æƒ³å®š
            # ã¾ãŸã¯ã€AdvisorConfigLoaderã®æ©Ÿèƒ½ã§å–å¾—ã—ãŸã‚‚ã®ã‚’æ¸¡ã™
            profile_name = report_data.get('profile_name', report_data.get("metadata", {}).get("profile", "æœªè¨­å®š"))
            profile_desc = report_data.get('profile_description', 
                                           UNIFIED_PROFILES.get(profile_name, {}).get("profile_description", "N/A"))
            print(f"æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {profile_name} ({profile_desc})")
            print("-" * 60)

            status = report_data.get('market_status', report_data.get("market_analysis", {}).get("current_status", {}))
            print(f"â–  S&P500 ç¾çŠ¶:")
            print(f"  - æœ€æ–°ä¾¡æ ¼ ({status.get('last_price_date', 'N/A')}): {status.get('current_price', 0.0):.2f}")
            if "VIX" in status: print(f"  - VIXæŒ‡æ•°: {status['VIX']:.2f}")

            preds = report_data.get('ai_predictions', report_data.get("market_analysis", {}).get("ai_predictions", {}))
            # errors ã¯ report_data.get("market_analysis", {}).get("ai_reliability", {}) ã‚’å‚ç…§ (ä¿®æ­£æ¡ˆ InvestmentAdvisor.generate_investment_advice å‚ç…§)
            errors = report_data.get('ai_error_rates', report_data.get("market_analysis", {}).get("ai_reliability", {}))
            print("\nâ–  AIä¾¡æ ¼äºˆæ¸¬ (LSTM):")

            # ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤ºã‚¨ãƒ©ãƒ¼ä¿®æ­£ (ä¿®æ­£4) åŠã³ ã‚­ãƒ¼åçµ±ä¸€ (ä¿®æ­£7) å¯¾å¿œ
            # `preds` ã¯ `_get_ai_predictions_summary` ã®çµæœã‚’æƒ³å®š (price, trend_pct, confidence ã‚’å«ã‚€)
            if "nextday" in preds and isinstance(preds["nextday"], dict): # ã‚­ãƒ¼åå¤‰æ›´: nextday_price -> nextday
                price = preds["nextday"].get("price", 0.0) # price ã‚­ãƒ¼ã‚’æœŸå¾…
                trend = preds["nextday"].get("trend_pct", 0.0) # trend_pct ã‚‚åˆ©ç”¨å¯èƒ½
                # æ”¹å–„æ¡ˆã®ä¿®æ­£4ã¯ price ã‚’è¡¨ç¤ºã™ã‚‹ãŒã€å…ƒã®ã‚³ãƒ¼ãƒ‰ã¯ä¾¡æ ¼ãã®ã‚‚ã®ã‚’è¡¨ç¤ºã—ã¦ã„ãŸ
                # ã“ã“ã§ã¯æ”¹å–„æ¡ˆã«å¾“ã„ price ã‚’è¡¨ç¤ºã—ã€MAPE ã‚‚è¡¨ç¤º
                print(f"  - ç¿Œæ—¥äºˆæ¸¬: {price:.2f} (ãƒˆãƒ¬ãƒ³ãƒ‰: {trend:.2f}%, MAPE: {errors.get('nextday_mape', errors.get('next_mape',0.0)):.2f}%)") # errorsã®ã‚­ãƒ¼ã‚‚ç¢ºèª
            
            # short_term, long_term ã¯å…ƒã€… trend_pct ã‚’è¡¨ç¤ºã—ã¦ã„ãŸã®ã§ã€price ãŒã‚ã‚Œã°ãã‚Œã‚‚è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«æ‹¡å¼µ
            short_p = preds.get('short_term', {})
            if short_p: # short_pãŒç©ºã§ãªã„ã“ã¨ã‚’ç¢ºèª
                short_price = short_p.get("price", None)
                display_price = f"{short_price:.2f}" if short_price is not None else "N/A"
                print(f"  - çŸ­æœŸ({short_p.get('days',0)}æ—¥å¾Œäºˆæ¸¬ä¾¡æ ¼): {display_price} (ãƒˆãƒ¬ãƒ³ãƒ‰: {short_p.get('trend_pct', 0.0):.2f}%, MAPE: {errors.get('short_mape', errors.get('short_term_mape',0.0)):.2f}%)")
            
            long_p = preds.get('long_term', {})
            if long_p: # long_pãŒç©ºã§ãªã„ã“ã¨ã‚’ç¢ºèª
                long_price = long_p.get("price", None)
                display_price = f"{long_price:.2f}" if long_price is not None else "N/A"
                print(f"  - é•·æœŸ({long_p.get('days',0)}æ—¥å¾Œäºˆæ¸¬ä¾¡æ ¼): {display_price} (ãƒˆãƒ¬ãƒ³ãƒ‰: {long_p.get('trend_pct', 0.0):.2f}%, MAPE: {errors.get('long_mape', errors.get('long_term_mape',0.0)):.2f}%)")

            tech = report_data.get('technical_signals', report_data.get("market_analysis", {}).get("technical_signals", {}))
            print("\nâ–  ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚µãƒãƒªãƒ¼:")
            print(f"  - MAã‚¯ãƒ­ã‚¹: {tech.get('ma_cross_status', 'æƒ…å ±ãªã—')}")
            recent_days = tech.get('recent_days_for_count',0)
            print(f"  - ç›´è¿‘{recent_days}æ—¥ã®ã‚·ã‚°ãƒŠãƒ«:")
            buy_c = tech.get('buy_signal_counts', {}) # å…ƒã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã“ã®ã‚­ãƒ¼ã¯ãªã„ãŒã€ã‚µãƒãƒªãƒ¼æ§‹é€ ã«åˆã‚ã›ã‚‹
            sell_c = tech.get('sell_signal_counts', {})# åŒä¸Š
            # total_buy_score, total_sell_scoreã‹ã‚‰è¡¨ç¤ºã‚’çµ„ã¿ç«‹ã¦ã‚‹ã®ãŒã‚ˆã‚Šé©åˆ‡ã‹
            buy_str = ', '.join([f'{k.replace("_signal","")}:{v}' for k,v in buy_c.items() if v>0]) or "ãªã—"
            sell_str = ', '.join([f'{k.replace("_signal","")}:{v}' for k,v in sell_c.items() if v>0]) or "ãªã—"
            print(f"    è²·ã„ã‚·ã‚°ãƒŠãƒ«åˆè¨ˆ: {tech.get('total_buy_score',0)} ({buy_str})")
            print(f"    å£²ã‚Šã‚·ã‚°ãƒŠãƒ«åˆè¨ˆ: {tech.get('total_sell_score',0)} ({sell_str})")

            print("-" * 60)
            # overall_advice ã¯ investment_advice.primary_action ã‚„ profile_adjusted_advice.advice_text ã‚’å‚ç…§
            advice_section = report_data.get("investment_advice", {})
            overall_advice_text = advice_section.get("profile_adjusted_advice", {}).get("advice_text", 
                                advice_section.get("primary_action", "åˆ¤æ–­ææ–™ä¸è¶³"))
            print(f"â–  ç·åˆç©ç«‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹:\n  {overall_advice_text}")
            print("-" * 60 + "\n")
        except Exception as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)


@dataclass
class MarketAssessment:
    """å¸‚å ´è©•ä¾¡ã®ç·åˆçµæœ"""
    trend: str
    confidence: float
    risk_level: str
    tech_score: float
    ai_reliability: float

class InvestmentAdvisor:
    """AIäºˆæ¸¬ä¿®æ­£ç‰ˆæŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼"""
    
    # PROFILES ã¨ builtin_config ã¯å‰Šé™¤ (ä¿®æ­£5)

    def __init__(self, market_data_dict: Dict, trained_models_results: Dict, 
                 logger_manager, # advisor_config_file ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‰Šé™¤ (ä¿®æ­£5)
                 initial_profile_name: str = "natural"):
        self.logger = logger_manager.get_logger(self.__class__.__name__)
        self.market_data_dict = market_data_dict
        self.trained_models_results = trained_models_results
        self.current_profile = initial_profile_name
        
        # çµ±ä¸€ã•ã‚ŒãŸãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å®šç¾©ã®ã¿ä½¿ç”¨ (ä¿®æ­£5)
        self.profile_config = UNIFIED_PROFILES.get(initial_profile_name, UNIFIED_PROFILES["natural"])
        
        self.sp500_df = self._get_sp500_data()
        self.calculation_errors = []
        
        self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªå¸‚å ´ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ¼: {list(self.market_data_dict.keys())}")
        self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«çµæœã‚­ãƒ¼: {list(self.trained_models_results.keys())}")
        self._debug_ai_predictions_detailed()
        
        self.logger.info(f"InvestmentAdvisoråˆæœŸåŒ–å®Œäº† - ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile}")

    def _extract_prediction_prices(self): # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ generate_investment_report ã§ç›´æ¥ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹
        """å„ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ä¾¡æ ¼ã‚’æŠ½å‡º"""
        prediction_prices = {}
        current_price_fallback = DEFAULT_SP500_PRICE # (ä¿®æ­£6)
        if not self.sp500_df.empty:
            current_price_fallback = self.sp500_df['Close'].iloc[-1]

        try:
            if 'nextday' in self.trained_models_results:
                nextday_result = self.trained_models_results['nextday']
                if 'latest_prediction_original' in nextday_result:
                    nextday_pred = nextday_result['latest_prediction_original']
                    price_val = 0
                    if isinstance(nextday_pred, (list, np.ndarray)) and len(nextday_pred) > 0:
                        price_val = float(nextday_pred[0])
                    elif isinstance(nextday_pred, (int, float)):
                        price_val = float(nextday_pred)
                    if price_val != 0:
                         prediction_prices['nextday'] = {
                            'price': round(price_val, 2), 'period': 'ç¿Œæ—¥'
                        }
            
            if 'short' in self.trained_models_results:
                short_result = self.trained_models_results['short']
                if 'latest_prediction_original' in short_result:
                    short_pred = short_result['latest_prediction_original']
                    if isinstance(short_pred, (list, np.ndarray)) and len(short_pred) > 0:
                        prediction_prices['short'] = {
                            'price': round(float(short_pred[-1]), 2), 'period': '20æ—¥å¾Œ'
                        }
            
            if 'long' in self.trained_models_results:
                long_result = self.trained_models_results['long']
                if 'latest_prediction_original' in long_result:
                    long_pred = long_result['latest_prediction_original']
                    if isinstance(long_pred, (list, np.ndarray)) and len(long_pred) > 0:
                        raw_long_price = self._extract_long_term_prediction(long_pred)
                        current_price_for_val = self.sp500_df['Close'].iloc[-1] if not self.sp500_df.empty else DEFAULT_SP500_PRICE # (ä¿®æ­£6)
                        validated_long_price = self._validate_prediction(current_price_for_val, raw_long_price, 'long')
                        prediction_prices['long'] = {
                            'price': round(float(validated_long_price), 2), 'period': '30æ—¥å¾Œ'
                        }
                        
            self.logger.info(f"äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºå®Œäº†: {prediction_prices}")
            return prediction_prices
            
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _extract_long_term_prediction(self, long_pred_array):
        """é•·æœŸäºˆæ¸¬ã®å®‰å®šåŒ– - ãƒã‚¤ã‚ºå‰Šæ¸›ã®ãŸã‚æœ€å¾Œã®æœŸé–“ã®å¹³å‡ã‚’ä½¿ç”¨"""
        try:
            if isinstance(long_pred_array, (list, np.ndarray)) and len(long_pred_array) > 20:
                stable_pred = np.mean(long_pred_array[-20:])
                original_pred = long_pred_array[-1]
                self.logger.debug(f"é•·æœŸäºˆæ¸¬å®‰å®šåŒ–: å…ƒå€¤={original_pred:.2f} â†’ å®‰å®šåŒ–å€¤={stable_pred:.2f}")
                return stable_pred
            elif len(long_pred_array) > 0:
                return long_pred_array[-1]
            else:
                self.logger.warning("é•·æœŸäºˆæ¸¬é…åˆ—ãŒç©ºã§ã™")
                return 0
        except Exception as e:
            self.logger.error(f"é•·æœŸäºˆæ¸¬æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return long_pred_array[-1] if len(long_pred_array) > 0 else 0

    def _validate_prediction(self, current_price: float, predicted_price: float, prediction_type: str) -> float:
        """äºˆæ¸¬å€¤ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ç•°å¸¸å€¤ã‚’è£œæ­£"""
        try:
            if current_price == 0: # ã‚¼ãƒ­é™¤ç®—ã‚’é¿ã‘ã‚‹
                self.logger.warning(f"{prediction_type}äºˆæ¸¬ã®æ¤œè¨¼: ç¾åœ¨ä¾¡æ ¼ãŒ0ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—")
                return predicted_price

            change_pct = ((predicted_price - current_price) / current_price) * 100
            thresholds = {'nextday': (-5, 5), 'short': (-15, 15), 'long': (-25, 25)}
            min_change, max_change = thresholds.get(prediction_type, (-30, 30))
            
            if change_pct < min_change or change_pct > max_change:
                self.logger.warning(f"{prediction_type}äºˆæ¸¬ãŒç•°å¸¸å€¤: {change_pct:.2f}% â†’ è£œæ­£å®Ÿè¡Œ")
                corrected_change = np.sign(change_pct) * min(abs(change_pct), abs(max_change))
                corrected_price = current_price * (1 + corrected_change / 100)
                self.logger.info(f"{prediction_type}äºˆæ¸¬è£œæ­£: {predicted_price:.2f} â†’ {corrected_price:.2f}")
                return corrected_price
            
            self.logger.debug(f"{prediction_type}äºˆæ¸¬ã¯å¦¥å½“ç¯„å›²å†…: {change_pct:.2f}%")
            return predicted_price
            
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬å€¤æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return current_price

    def _log_prediction_summary(self):
        """äºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ã‚’ãƒ­ã‚°å‡ºåŠ›"""
        try:
            prediction_prices = self._extract_prediction_prices()
            self.logger.info("=== AIäºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ ===")
            for model_name, pred_data in prediction_prices.items():
                self.logger.info(f"{model_name}ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ä¾¡æ ¼: ${pred_data['price']:,.2f} ({pred_data['period']})")
            
            if not self.sp500_df.empty:
                current_price = self.sp500_df['Close'].iloc[-1]
                self.logger.info(f"ç¾åœ¨ä¾¡æ ¼: ${current_price:,.2f}")
                if 'nextday' in prediction_prices:
                    change = prediction_prices['nextday']['price'] - current_price
                    if current_price != 0:
                        change_pct = (change / current_price) * 100
                        self.logger.info(f"ç¿Œæ—¥äºˆæ¸¬å¤‰åŒ–: ${change:+.2f} ({change_pct:+.2f}%)")
                    else:
                        self.logger.info(f"ç¿Œæ—¥äºˆæ¸¬å¤‰åŒ–: ${change:+.2f} (ç¾åœ¨ä¾¡æ ¼0ã®ãŸã‚%è¨ˆç®—ä¸å¯)")
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬ã‚µãƒãƒªãƒ¼ãƒ­ã‚°ã‚¨ãƒ©ãƒ¼: {e}")

    def _display_enhanced_report(self, report_data: Dict[str, Any]):
        """å¼·åŒ–ã•ã‚ŒãŸãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º"""
        prediction_prices = self._extract_prediction_prices() # ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤ºç”¨ã«æœ€æ–°ã®äºˆæ¸¬ä¾¡æ ¼ã‚’å–å¾—
        
        print("\n" + "="*60)
        print("        ğŸ¯ AIæŠ•è³‡åˆ†æãƒ¬ãƒãƒ¼ãƒˆï¼ˆå¼·åŒ–ç‰ˆï¼‰ ğŸ¯")
        print("="*60)
        print(f"ğŸ“… ç”Ÿæˆæ—¥æ™‚: {report_data.get('metadata', {}).get('generated_at', datetime.now().isoformat())}")
        print(f"ğŸ‘¤ æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile.upper()}")
        
        print("\nğŸ”® ã€AIäºˆæ¸¬ä¾¡æ ¼ã€‘") # _extract_prediction_prices ã®çµæœã‚’ä½¿ç”¨
        if 'nextday' in prediction_prices:
            print(f"ç¿Œæ—¥äºˆæ¸¬: ${prediction_prices['nextday']['price']:,.2f}")
        if 'short' in prediction_prices:
            print(f"çŸ­æœŸäºˆæ¸¬ï¼ˆ20æ—¥å¾Œï¼‰: ${prediction_prices['short']['price']:,.2f}")
        if 'long' in prediction_prices:
            print(f"é•·æœŸäºˆæ¸¬ï¼ˆ30æ—¥å¾Œï¼‰: ${prediction_prices['long']['price']:,.2f}")
        
        assessment = report_data.get("assessment", {})
        advice = report_data.get("investment_advice", {})
        market = report_data.get("market_analysis", {}).get("current_status", {})
        
        # AIäºˆæ¸¬åˆ†æã¯ _get_ai_predictions_summary ã®çµæœ (trend_pct, confidence) ã‚’ä½¿ç”¨
        ai_predictions_summary = report_data.get("market_analysis", {}).get("ai_predictions", {})
        long_term_summary = ai_predictions_summary.get("long_term", {})
        ai_trend = long_term_summary.get("trend_pct", 0) # ã‚­ãƒ¼åçµ±ä¸€(ä¿®æ­£7)
        ai_confidence = long_term_summary.get("confidence", 0)
        
        print(f"\nğŸ¤– ã€AIäºˆæ¸¬åˆ†æ (ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ™ãƒ¼ã‚¹)ã€‘")
        print(f"é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬: {ai_trend:+.2f}%")
        print(f"AIä¿¡é ¼åº¦: {ai_confidence:.1%}")
        
        print(f"\nğŸ“Š ã€ç·åˆè©•ä¾¡ã€‘")
        print(f"ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.get('overall_trend', 'N/A').upper()}")
        print(f"ä¿¡é ¼åº¦: {assessment.get('confidence_score', 0):.1%}")
        print(f"ãƒªã‚¹ã‚¯: {assessment.get('risk_level', 'N/A').upper()}")
        print(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢: {assessment.get('technical_score', 0):.2f}")
        print(f"AIä¿¡é ¼åº¦ (ç·åˆè©•ä¾¡æ™‚): {assessment.get('ai_reliability', 0):.1%}")
        
        print(f"\nğŸ’¡ ã€æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€‘")
        print(f"ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {advice.get('primary_action', 'N/A')}")
        print(f"å¼·åº¦: {advice.get('action_strength', 'N/A')}")
        
        profile_advice = advice.get("profile_adjusted_advice", {})
        if profile_advice:
            print(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¹: {profile_advice.get('advice_text', 'N/A')}")
            print(f"æ¨å¥¨ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚º: {profile_advice.get('position_sizing', 'N/A')}")
        
        key_factors = advice.get("key_factors", [])
        if key_factors: print(f"\nğŸ” ã€ä¸»è¦åˆ¤æ–­è¦å› ã€‘"); [print(f"â€¢ {factor}") for factor in key_factors]
        
        warnings = advice.get("warnings", [])
        if warnings: print(f"\nâš ï¸ ã€è­¦å‘Šãƒ»æ³¨æ„äº‹é …ã€‘"); [print(f"{i}. {warning}") for i, warning in enumerate(warnings[:3], 1)]
        
        if market and "error" not in market:
            print(f"\nğŸ“ˆ ã€å¸‚å ´çŠ¶æ³ã€‘")
            print(f"S&P500ä¾¡æ ¼: ${market.get('current_price', 0):.2f}")
            print(f"æ—¥æ¬¡å¤‰å‹•: {market.get('daily_change', 0):+.2f}%")
            print(f"VIXæŒ‡æ•°: {market.get('VIX', 0):.1f} ({market.get('vix_level', 'N/A')})")
            print(f"5æ—¥ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£: {market.get('volatility_5d', 0):.1f}%")
        
        print("="*60)

    def _debug_ai_predictions_detailed(self):
        """AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒ‡ãƒãƒƒã‚°"""
        self.logger.info("=== AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿è©³ç´°åˆ†æ ===")
        for model_key, model_result in self.trained_models_results.items():
            self.logger.info(f"\n--- {model_key}ãƒ¢ãƒ‡ãƒ«è©³ç´° ---")
            if isinstance(model_result, dict):
                for key, value in model_result.items():
                    if isinstance(value, list): self.logger.info(f"  {key}: List[{len(value)}] - æœ€å¾Œã®3ã¤: {value[-3:]}" if len(value)>0 else f"  {key}: ç©ºã®ãƒªã‚¹ãƒˆ")
                    elif isinstance(value, (int, float)): self.logger.info(f"  {key}: {value}")
                    else: self.logger.info(f"  {key}: {type(value)}")
                if 'y_pred_original_test' in model_result and 'y_test_original_test' in model_result:
                    pred = model_result['y_pred_original_test']; actual = model_result['y_test_original_test']
                    if isinstance(pred, list) and isinstance(actual, list) and len(pred)>0 and len(actual)>0 :
                        self.logger.info(f"  äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿é•·: {len(pred)}, å®Ÿéš›ãƒ‡ãƒ¼ã‚¿é•·: {len(actual)}")
                        self.logger.info(f"  æœ€å¾Œã®äºˆæ¸¬å€¤: {pred[-1]}, æœ€å¾Œã®å®Ÿéš›å€¤: {actual[-1]}")
                if 'latest_prediction_original' in model_result: self.logger.info(f"  æœ€æ–°äºˆæ¸¬å€¤: {model_result['latest_prediction_original']}")

    def _get_sp500_data(self) -> Optional[pd.DataFrame]:
        """S&P500ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«å–å¾—"""
        try:
            for key in ["^GSPC", "SP500", "SPX", "sp500"]:
                if key in self.market_data_dict:
                    data = self.market_data_dict[key]
                    if isinstance(data, dict) and "df" in data and data["df"] is not None and not data["df"].empty:
                        self.logger.info(f"S&P500ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ ({key}): {len(data['df'])}è¡Œ")
                        return data["df"]
                    elif isinstance(data, pd.DataFrame) and not data.empty:
                        self.logger.info(f"S&P500ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ ({key}): {len(data)}è¡Œ")
                        return data
            self.logger.error("S&P500ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return pd.DataFrame()
        except Exception as e:
            self.logger.error(f"S&P500ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return pd.DataFrame()

    # (ä¿®æ­£4, ä¿®æ­£7 ã®ãŸã‚ã®å¤‰æ›´) _calculate_ai_prediction_from_model_data ãŒäºˆæ¸¬ä¾¡æ ¼ã‚‚è¿”ã™ã‚ˆã†ã«å¤‰æ›´
    def _calculate_ai_prediction_from_model_data(self, model_result: Dict, model_type: str) -> tuple[float, float, float]:
        """ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰AIäºˆæ¸¬(ãƒˆãƒ¬ãƒ³ãƒ‰%ã€ä¿¡é ¼åº¦ã€äºˆæ¸¬ä¾¡æ ¼)ã‚’è¨ˆç®—"""
        default_price = DEFAULT_SP500_PRICE # (ä¿®æ­£6)
        if not self.sp500_df.empty:
            default_price = self.sp500_df['Close'].iloc[-1]

        try:
            current_price = default_price # é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã§å®šç¾©
            predicted_price_val = default_price # äºˆæ¸¬ä¾¡æ ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: latest_prediction_original
            if 'latest_prediction_original' in model_result:
                latest_pred_raw = model_result['latest_prediction_original']
                
                if isinstance(latest_pred_raw, (list, np.ndarray)) and len(latest_pred_raw) > 0:
                    predicted_price_val = latest_pred_raw[0] if model_type == 'nextday' else latest_pred_raw[-1]
                elif isinstance(latest_pred_raw, (int, float)):
                    predicted_price_val = latest_pred_raw
                
                if isinstance(predicted_price_val, (int, float)) and predicted_price_val != 0:
                    current_price_to_use = self.sp500_df['Close'].iloc[-1] if not self.sp500_df.empty else predicted_price_val
                    if current_price_to_use == 0: current_price_to_use = predicted_price_val # ã‚¼ãƒ­é™¤ç®—å›é¿
                    
                    change_pct = ((predicted_price_val - current_price_to_use) / current_price_to_use) * 100 if current_price_to_use != 0 else 0
                    mape = model_result.get('mape_test', 50)
                    confidence = max(0.1, min(0.95, (100 - mape) / 100))
                    self.logger.info(f"{model_type}: æœ€æ–°äºˆæ¸¬={predicted_price_val:.2f}, ç¾åœ¨ä¾¡æ ¼={current_price_to_use:.2f}, ãƒˆãƒ¬ãƒ³ãƒ‰%={change_pct:.2f}%, MAPE={mape:.2f}%")
                    return change_pct, confidence, float(predicted_price_val)
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: y_pred_original_testã¨y_test_original_test
            if 'y_pred_original_test' in model_result and 'y_test_original_test' in model_result:
                pred_data = model_result['y_pred_original_test']
                actual_data = model_result['y_test_original_test']
                if isinstance(pred_data, list) and isinstance(actual_data, list) and len(pred_data) > 0:
                    predicted_price_val = pred_data[-1]
                    latest_actual = actual_data[-1] if len(actual_data) > 0 else predicted_price_val
                    if latest_actual == 0: latest_actual = predicted_price_val # ã‚¼ãƒ­é™¤ç®—å›é¿

                    change_pct = ((predicted_price_val - latest_actual) / latest_actual) * 100 if latest_actual !=0 else 0
                    mape = model_result.get('mape_test', 50)
                    confidence = max(0.1, min(0.95, (100 - mape) / 100))
                    self.logger.info(f"{model_type}: äºˆæ¸¬={predicted_price_val:.2f}, å®Ÿéš›={latest_actual:.2f}, ãƒˆãƒ¬ãƒ³ãƒ‰%={change_pct:.2f}%, MAPE={mape:.2f}%")
                    return change_pct, confidence, float(predicted_price_val)
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³3: predict_step
            if 'predict_step' in model_result:
                predict_step = model_result['predict_step']
                current_price_for_step = self.sp500_df['Close'].iloc[-1] if not self.sp500_df.empty else DEFAULT_SP500_PRICE # (ä¿®æ­£6)
                
                if not self.sp500_df.empty and len(self.sp500_df) >= predict_step:
                    past_returns = self.sp500_df['Close'].pct_change().dropna().tail(predict_step)
                    avg_return = past_returns.mean()
                    predicted_price_val = current_price_for_step * (1 + avg_return * predict_step)
                    if current_price_for_step == 0: current_price_for_step = predicted_price_val # ã‚¼ãƒ­é™¤ç®—å›é¿
                    change_pct = ((predicted_price_val - current_price_for_step) / current_price_for_step) * 100 if current_price_for_step != 0 else 0
                    mape = model_result.get('mape_test', 30)
                    confidence = max(0.1, min(0.95, (100 - mape) / 100))
                    self.logger.info(f"{model_type}: æ®µéšäºˆæ¸¬={predict_step}, ãƒˆãƒ¬ãƒ³ãƒ‰%={change_pct:.2f}%, MAPE={mape:.2f}%")
                    return change_pct, confidence, float(predicted_price_val)
            
            self.logger.warning(f"{model_type}: äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è¨ˆç®—ã«å¤±æ•—")
            return 0.0, 0.5, default_price
            
        except Exception as e:
            self.logger.error(f"{model_type} AIäºˆæ¸¬è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return 0.0, 0.5, default_price

    def _get_ai_predictions_summary(self) -> tuple[Dict[str, Any], Dict[str, Any]]:
        """AIäºˆæ¸¬ã®ã‚µãƒãƒªãƒ¼ã‚’å–å¾—ï¼ˆä¿®æ­£ç‰ˆï¼‰"""
        predictions = {}
        errors = {}
        
        try:
            self.logger.info("=== AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼ç”Ÿæˆé–‹å§‹ï¼ˆä¿®æ­£ç‰ˆï¼‰ ===")
            for model_key, model_result in self.trained_models_results.items():
                if not isinstance(model_result, dict): continue
                self.logger.info(f"å‡¦ç†ä¸­ã®ãƒ¢ãƒ‡ãƒ«: {model_key}")
                
                # _calculate_ai_prediction_from_model_data ã¯ (trend_pct, confidence, predicted_price) ã‚’è¿”ã™ (ä¿®æ­£4, ä¿®æ­£7 å¯¾å¿œ)
                trend_pct, confidence, predicted_price = self._calculate_ai_prediction_from_model_data(model_result, model_key)
                
                mape = model_result.get('mape_test', 50)
                
                # ã‚­ãƒ¼åçµ±ä¸€ (ä¿®æ­£7): nextday_price -> nextday, change_pct -> trend_pct
                # äºˆæ¸¬çµæœã« price ã‚‚å«ã‚ã‚‹ (ä¿®æ­£4 å¯¾å¿œ)
                current_pred_data = {"trend_pct": trend_pct, "confidence": confidence, "price": predicted_price}
                
                if 'long' in model_key.lower():
                    predictions["long_term"] = current_pred_data
                    errors[f"long_term_mape"] = mape # ã‚¨ãƒ©ãƒ¼ã‚­ãƒ¼ã‚‚çµ±ä¸€æ€§ã‚’æŒãŸã›ã‚‹
                elif 'short' in model_key.lower():
                    predictions["short_term"] = current_pred_data
                    errors[f"short_term_mape"] = mape
                elif 'nextday' in model_key.lower() or 'next' in model_key.lower():
                    predictions["nextday"] = current_pred_data # ã‚­ãƒ¼åå¤‰æ›´
                    errors[f"nextday_mape"] = mape # ã‚¨ãƒ©ãƒ¼ã‚­ãƒ¼ã‚‚åˆã‚ã›ã‚‹
                else: # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯é•·æœŸæ‰±ã„
                    predictions["long_term"] = current_pred_data
                    errors[f"long_term_mape"] = mape # (long_term_mapeãŒä¸Šæ›¸ãã•ã‚Œã‚‹å¯èƒ½æ€§)

            if not predictions.get("long_term"): # é•·æœŸäºˆæ¸¬ãŒãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                best_model_key = None; best_mape = float('inf')
                for mk, mr in self.trained_models_results.items():
                    if isinstance(mr, dict) and 'mape_test' in mr and mr.get('mape_test', 100) < best_mape:
                        best_mape = mr['mape_test']; best_model_key = mk
                if best_model_key:
                    trend_pct, confidence, predicted_price = self._calculate_ai_prediction_from_model_data(
                        self.trained_models_results[best_model_key], best_model_key
                    )
                    predictions["long_term"] = {"trend_pct": trend_pct, "confidence": confidence, "price": predicted_price}
                    errors["long_term_mape"] = best_mape
                    self.logger.info(f"æœ€è‰¯ãƒ¢ãƒ‡ãƒ« {best_model_key} ã‹ã‚‰é•·æœŸäºˆæ¸¬ç”Ÿæˆ: {trend_pct:.2f}%")
            
            self.logger.info(f"æœ€çµ‚çš„ãªAIäºˆæ¸¬: {predictions}")
            return predictions, errors
            
        except Exception as e:
            self.logger.error(f"AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {}, {}

    def _get_vix_value(self) -> float:
        """VIXå€¤ã‚’å–å¾—ï¼ˆS&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç›´æ¥å–å¾—ã‚’å„ªå…ˆï¼‰"""
        try:
            if not self.sp500_df.empty and 'VIX' in self.sp500_df.columns:
                vix_series = self.sp500_df['VIX'].dropna()
                if len(vix_series) > 0: return float(vix_series.iloc[-1])
            
            for key in ["VIX", "^VIX", "vix", "volatility"]:
                if key in self.market_data_dict:
                    vix_data = self.market_data_dict[key]
                    if isinstance(vix_data, dict):
                        if "df" in vix_data and not vix_data["df"].empty and "Close" in vix_data["df"].columns:
                            return float(vix_data["df"]["Close"].iloc[-1])
                        elif "Close" in vix_data and isinstance(vix_data["Close"], list) and len(vix_data["Close"]) > 0:
                            return float(vix_data["Close"][-1])
                    elif isinstance(vix_data, (int, float)): return float(vix_data)
            
            if not self.sp500_df.empty: # S&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’è¨ˆç®—ã—ã¦ä»£ç”¨
                returns = self.sp500_df['Close'].pct_change().dropna().tail(20)
                if len(returns) > 0:
                    volatility = returns.std() * np.sqrt(252) * 100
                    estimated_vix = min(80, max(10, volatility))
                    self.logger.info(f"VIXæ¨å®šå€¤: {estimated_vix:.1f} (ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã‹ã‚‰è¨ˆç®—)")
                    return estimated_vix
            
            self.logger.warning(f"VIXå€¤ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ {VIX_DEFAULT} ã‚’ä½¿ç”¨")
            return VIX_DEFAULT
            
        except Exception as e:
            self.logger.error(f"VIXå–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return VIX_DEFAULT

    def _calculate_technical_indicators(self) -> Dict[str, Any]:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—ï¼ˆS&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç›´æ¥å–å¾—ã‚’å„ªå…ˆï¼‰"""
        if self.sp500_df.empty: return {}
        tech_data = {}
        try:
            # RSI
            if 'RSI' in self.sp500_df.columns: current_rsi = self.sp500_df['RSI'].iloc[-1]
            elif len(self.sp500_df) >= 14:
                delta = self.sp500_df['Close'].diff(); gain = (delta.where(delta > 0, 0)).rolling(window=14).mean(); loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
                rs = gain / loss; rsi_series = 100 - (100 / (1 + rs)); current_rsi = rsi_series.iloc[-1] if not rsi_series.empty else np.nan
            else: current_rsi = np.nan

            if pd.notna(current_rsi):
                tech_data["rsi_current"] = float(current_rsi)
                tech_data["rsi_signal"] = "éè²·ã„" if current_rsi >= RSI_OVERBOUGHT else ("éå£²ã‚Š" if current_rsi <= RSI_OVERSOLD else "ä¸­ç«‹")
            
            # ç§»å‹•å¹³å‡ç·š
            df = self.sp500_df.copy(); current_price = df['Close'].iloc[-1]
            ma_columns = [col for col in df.columns if col.startswith('MA') and col[2:].isdigit()]
            ma_signals = {}
            if ma_columns:
                for ma_col in ['MA5', 'MA20', 'MA50', 'MA60', 'MA120']:
                    if ma_col in df.columns and pd.notna(df[ma_col].iloc[-1]): ma_signals[f"price_vs_{ma_col.lower()}"] = "above" if current_price > df[ma_col].iloc[-1] else "below"
                if 'MA5' in df.columns and 'MA20' in df.columns and pd.notna(df['MA5'].iloc[-1]) and pd.notna(df['MA20'].iloc[-1]):
                    ma_signals["ma5_vs_ma20"] = "above" if df['MA5'].iloc[-1] > df['MA20'].iloc[-1] else "below"
            elif len(df) >= 50:
                df['MA5'] = df['Close'].rolling(5).mean(); df['MA20'] = df['Close'].rolling(20).mean(); df['MA50'] = df['Close'].rolling(50).mean()
                latest = df.iloc[-1]
                if pd.notna(latest['MA5']): ma_signals["price_vs_ma5"] = "above" if current_price > latest['MA5'] else "below"
                if pd.notna(latest['MA20']): ma_signals["price_vs_ma20"] = "above" if current_price > latest['MA20'] else "below"
                if pd.notna(latest['MA50']): ma_signals["price_vs_ma50"] = "above" if current_price > latest['MA50'] else "below"
                if pd.notna(latest['MA5']) and pd.notna(latest['MA20']): ma_signals["ma5_vs_ma20"] = "above" if latest['MA5'] > latest['MA20'] else "below"
            if ma_signals: tech_data["ma_signals"] = ma_signals
            
            # ã‚¯ãƒ­ã‚¹
            if 'golden_cross' in self.sp500_df.columns and 'death_cross' in self.sp500_df.columns:
                recent_data = self.sp500_df.tail(30)
                tech_data["recent_cross"] = "golden" if recent_data['golden_cross'].any() else ("death" if recent_data['death_cross'].any() else "none")
            
            self.logger.info(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—å®Œäº†: {tech_data}")
            return tech_data
        except Exception as e: self.logger.error(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}"); return {}

    def _get_technical_signals_summary(self) -> Dict[str, Any]:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚·ã‚°ãƒŠãƒ«ã®ã‚µãƒãƒªãƒ¼ï¼ˆæ”¹è‰¯ç‰ˆï¼‰"""
        summary = {"ma_cross_status": "MAã‚¯ãƒ­ã‚¹ã¯30æ—¥ä»¥å†…ã«ãªã—", "total_buy_score": 0, "total_sell_score": 0, "recent_days_for_count": 15, "rsi_signal": "ä¸­ç«‹"}
        try:
            tech_indicators = self._calculate_technical_indicators(); summary.update(tech_indicators)
            buy_score, sell_score = 0, 0
            if "rsi_signal" in tech_indicators:
                if tech_indicators["rsi_signal"] == "éå£²ã‚Š": buy_score += 3
                elif tech_indicators["rsi_signal"] == "éè²·ã„": sell_score += 3
                else: rsi_val = tech_indicators.get("rsi_current", 50); buy_score += 1 if rsi_val < 40 else (0); sell_score += 1 if rsi_val > 60 else (0)
            if "ma_signals" in tech_indicators:
                ma_s = tech_indicators["ma_signals"]
                above_c = sum(1 for k,v in ma_s.items() if k.startswith("price_vs_") and v == "above")
                below_c = sum(1 for k,v in ma_s.items() if k.startswith("price_vs_") and v == "below")
                buy_score += above_c if above_c > below_c else 0; sell_score += below_c if below_c > above_c else 0
                buy_score += 1 if ma_s.get("ma5_vs_ma20") == "above" else 0; sell_score += 1 if ma_s.get("ma5_vs_ma20") == "below" else 0
            if "recent_cross" in tech_indicators:
                if tech_indicators["recent_cross"] == "golden": buy_score += 2; summary["ma_cross_status"] = "ç›´è¿‘ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¯ãƒ­ã‚¹ç™ºç”Ÿ"
                elif tech_indicators["recent_cross"] == "death": sell_score += 2; summary["ma_cross_status"] = "ç›´è¿‘ãƒ‡ãƒƒãƒ‰ã‚¯ãƒ­ã‚¹ç™ºç”Ÿ"
            summary["total_buy_score"] = buy_score; summary["total_sell_score"] = sell_score
            self.logger.info(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚µãƒãƒªãƒ¼: è²·ã„={buy_score}, å£²ã‚Š={sell_score}")
            return summary
        except Exception as e: self.logger.error(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚¨ãƒ©ãƒ¼: {e}"); return {"error": str(e)}

    def _generate_comprehensive_market_assessment(self, market_status: Dict, predictions: Dict, 
                                                  errors: Dict, tech_signals: Dict) -> MarketAssessment:
        """ç·åˆå¸‚å ´è©•ä¾¡ã‚’ç”Ÿæˆï¼ˆAIäºˆæ¸¬é‡è¦–ï¼‹æ¥µç«¯å€¤æŠ‘åˆ¶ãƒ»é‡ã¿èª¿æ•´ç‰ˆï¼‰"""
        try:
            # ã‚­ãƒ¼åçµ±ä¸€ (ä¿®æ­£7): nextday_price -> nextday. å†…éƒ¨ã‚­ãƒ¼ã¯ trend_pct.
            for period in ['nextday', 'short_term', 'long_term']: 
                pred = predictions.get(period, {})
                trend_pct_val = pred.get('trend_pct', 0) # ã™ã¹ã¦ trend_pct ã§çµ±ä¸€
                confidence = pred.get('confidence', 0.5)
                if abs(trend_pct_val) > 20: pred['confidence'] = confidence * 0.5
                elif abs(trend_pct_val) > 10: pred['confidence'] = confidence * 0.8
            
            # ã‚­ãƒ¼åçµ±ä¸€ (ä¿®æ­£7): weights ã®ã‚­ãƒ¼ã‚‚ nextday ã«å¤‰æ›´
            weights = {'nextday': 0.4, 'short_term': 0.4, 'long_term': 0.2} 
            weighted_trend, total_weight = 0, 0
            for period in ['nextday', 'short_term', 'long_term']:
                pred = predictions.get(period, {})
                trend = pred.get('trend_pct', 0) # ã™ã¹ã¦ trend_pct ã§çµ±ä¸€
                conf = pred.get('confidence', 0)
                weight = weights[period] * conf
                weighted_trend += trend * weight; total_weight += weight
            final_trend = weighted_trend / total_weight if total_weight > 0 else 0
            final_confidence = total_weight / sum(weights.values()) if sum(weights.values()) > 0 else 0.5

            trend_label = "bearish" if final_trend < -3 else ("bullish" if final_trend > 3 else "neutral")
            buy_score, sell_score = tech_signals.get("total_buy_score", 0), tech_signals.get("total_sell_score", 0)

            if trend_label == "bullish" and sell_score > buy_score + 2: trend_label = "neutral"; final_confidence *= 0.8
            elif trend_label == "bearish" and buy_score > sell_score + 2: trend_label = "neutral"; final_confidence *= 0.8
            elif trend_label == "neutral":
                if buy_score > sell_score + 1: trend_label = "bullish"; final_confidence += 0.1
                elif sell_score > buy_score + 1: trend_label = "bearish"; final_confidence += 0.1
            
            vix_value, volatility = market_status.get("VIX", VIX_DEFAULT), market_status.get("volatility_5d", 0)
            risk_factors = (3 if vix_value > 30 else (2 if vix_value > 25 else (1 if vix_value > 20 else 0))) + \
                           (2 if volatility > 25 else (1 if volatility > 15 else 0)) + \
                           (1 if final_confidence < 0.4 else 0)
            risk_level = "high" if risk_factors >= 5 else ("medium" if risk_factors >= 2 else "low")
            
            tech_score = buy_score / (buy_score + sell_score) if (buy_score + sell_score) > 0 else 0.5
            result = MarketAssessment(trend=trend_label, confidence=max(0.1, min(0.9, final_confidence)),
                                      risk_level=risk_level, tech_score=max(0.0, min(1.0, tech_score)),
                                      ai_reliability=final_confidence)
            self.logger.info(f"ç·åˆè©•ä¾¡: {trend_label}, ä¿¡é ¼åº¦={result.confidence:.2f}, ãƒªã‚¹ã‚¯={risk_level}")
            return result
        except Exception as e:
            self.logger.error(f"ç·åˆå¸‚å ´è©•ä¾¡ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return MarketAssessment("neutral", 0.5, "medium", 0.5, 0.5)

    # æœªå®Ÿè£…ãƒ¡ã‚½ãƒƒãƒ‰å®Œæˆ (ä¿®æ­£8)
    def _get_current_config(self) -> Dict[str, Any]:
        """ç¾åœ¨ã®è¨­å®šæƒ…å ±ã‚’å–å¾—"""
        return {
            "profile_name": self.current_profile,
            "profile_config": self.profile_config, # __init__ ã§ UNIFIED_PROFILES ã‹ã‚‰è¨­å®šæ¸ˆã¿
            "available_profiles": list(UNIFIED_PROFILES.keys())
        }

    # æ–°è¦è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰ (ä¿®æ­£8)
    def set_profile(self, profile_name: str) -> bool:
        """ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´"""
        if profile_name in UNIFIED_PROFILES:
            self.current_profile = profile_name
            self.profile_config = UNIFIED_PROFILES[profile_name] # self.profile_config ã‚‚æ›´æ–°
            self.logger.info(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ '{profile_name}' ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚")
            return True
        else:
            self.logger.warning(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« '{profile_name}' ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚")
            return False

    def _get_current_profile_name(self) -> str: # æ—¢å­˜ã ãŒã€_get_current_config ã¨åˆã‚ã›ã¦ç¢ºèª
        return self.current_profile

    def _get_current_market_status(self) -> Dict[str, Any]:
        if self.sp500_df is None or self.sp500_df.empty: return {"error": "ãƒ‡ãƒ¼ã‚¿ä¸è¶³"}
        try:
            latest_row = self.sp500_df.iloc[-1]; current_price = float(latest_row["Close"])
            daily_change = ((current_price - float(self.sp500_df["Close"].iloc[-2])) / float(self.sp500_df["Close"].iloc[-2])) * 100 if len(self.sp500_df) > 1 and float(self.sp500_df["Close"].iloc[-2]) != 0 else 0
            vix_value = self._get_vix_value()
            volatility_5d = float(self.sp500_df["Close"].pct_change().dropna().tail(5).std() * np.sqrt(252) * 100) if len(self.sp500_df) >= 5 else 0
            status = {"current_price": current_price, "last_price_date": self.sp500_df.index[-1].strftime("%Y-%m-%d"),
                      "volume": float(latest_row.get("Volume", 0)), "daily_change": daily_change,
                      "volatility_5d": volatility_5d, "VIX": vix_value, "vix_level": self._categorize_vix(vix_value)}
            self.logger.info(f"å¸‚å ´çŠ¶æ³: ä¾¡æ ¼=${current_price:.2f}, å¤‰å‹•={daily_change:.2f}%, VIX={vix_value:.1f}")
            return status
        except Exception as e: self.logger.error(f"å¸‚å ´çŠ¶æ³å–å¾—ã‚¨ãƒ©ãƒ¼: {e}"); return {"error": str(e)}

    def _categorize_vix(self, vix_value: float) -> str:
        if vix_value < 15: return "ä½ä½å®‰å®š"
        elif vix_value < 25: return "é€šå¸¸ç¯„å›²"
        elif vix_value < 35: return "è­¦æˆ’ãƒ¬ãƒ™ãƒ«"
        else: return "ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«"

    def _generate_investment_advice_from_assessment(self, assessment: MarketAssessment) -> Dict[str, Any]:
        try:
            # _get_current_config() ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­å®šã‚’å–å¾— (ä¿®æ­£8)
            current_advisor_config = self._get_current_config()
            profile_specific_config = current_advisor_config["profile_config"]
            confidence_threshold = profile_specific_config.get("confidence_threshold", 0.6)
            
            predictions, _ = self._get_ai_predictions_summary()
            # ã‚­ãƒ¼åçµ±ä¸€ (ä¿®æ­£7): long_term ã® trend_pct ã‚’å‚ç…§
            ai_trend = predictions.get("long_term", {}).get("trend_pct", 0)
            
            primary_action, action_strength, reason = "HOLD", "ä¸­", "æ˜ç¢ºãªãƒˆãƒ¬ãƒ³ãƒ‰ãªã—"
            if assessment.confidence < confidence_threshold:
                primary_action, action_strength, reason = "HOLD", "å¼±", f"ä¿¡é ¼åº¦{assessment.confidence:.1%}ãŒé–¾å€¤{confidence_threshold:.1%}æœªæº€"
            elif assessment.trend == "bullish" and assessment.risk_level != "high":
                if abs(ai_trend) > 1 and ai_trend > 0:
                    primary_action, action_strength, reason = "BUY", "å¼·" if assessment.confidence > 0.8 and ai_trend > 3 else "ä¸­", f"ä¸Šæ˜‡ãƒˆãƒ¬ãƒ³ãƒ‰(AI: +{ai_trend:.1f}%)"
                else:
                    primary_action, action_strength, reason = "BUY", "å¼±", "ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ä¸Šæ˜‡ã ãŒAIäºˆæ¸¬ä¸æ˜ç¢º"
            elif assessment.trend == "bearish" or (abs(ai_trend) > 1 and ai_trend < -2):
                primary_action, action_strength, reason = "SELL", "å¼·" if ai_trend < -3 else "ä¸­", f"ä¸‹é™ãƒˆãƒ¬ãƒ³ãƒ‰(AI: {ai_trend:.1f}%)"
            
            warnings = []
            if ai_trend < -5: warnings.append(f"ğŸš¨ AIäºˆæ¸¬ãŒå¤§å¹…ä¸‹è½è­¦å‘Š: {ai_trend:.1f}%")
            elif ai_trend < -2: warnings.append(f"âš ï¸ AIäºˆæ¸¬ãŒä¸‹è½ç¤ºå”†: {ai_trend:.1f}%")
            elif ai_trend > 5: warnings.append(f"ğŸ“ˆ AIäºˆæ¸¬ãŒå¤§å¹…ä¸Šæ˜‡ç¤ºå”†: +{ai_trend:.1f}%")
            if assessment.risk_level == "high": warnings.append("âš ï¸ é«˜ãƒªã‚¹ã‚¯å¸‚å ´ç’°å¢ƒ")
            if assessment.confidence < 0.4: warnings.append("âš ï¸ äºˆæ¸¬ä¿¡é ¼åº¦ ä½")
            if assessment.ai_reliability < 0.4: warnings.append("âš ï¸ AIäºˆæ¸¬ä¿¡é ¼æ€§ ä½")
            warnings.extend(["æŠ•è³‡ã¯è‡ªå·±è²¬ä»»ã§ã€‚", "ä½™è£•è³‡é‡‘ã§ã®æŠ•è³‡ã‚’ã€‚"])
            
            return {"primary_action": primary_action, "action_strength": action_strength, "risk_assessment": f"{assessment.risk_level}ãƒªã‚¹ã‚¯",
                    "confidence_score": assessment.confidence,
                    "profile_adjusted_advice": {"advice_text": f"ã€{self.current_profile.upper()}ã€‘{primary_action}æ¨å¥¨ï¼ˆ{action_strength}ï¼‰- {reason}",
                                                "position_sizing": self._get_position_sizing_advice(primary_action, assessment.risk_level)},
                    "key_factors": [f"AIãƒˆãƒ¬ãƒ³ãƒ‰: {ai_trend:+.1f}%", f"å¸‚å ´ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.trend}", f"ä¿¡é ¼åº¦: {assessment.confidence:.1%}",
                                    f"ãƒªã‚¹ã‚¯: {assessment.risk_level}", f"AIä¿¡é ¼åº¦: {assessment.ai_reliability:.1%}"],
                    "recommendations": self._get_basic_recommendations(primary_action), "warnings": warnings[:5]}
        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"error": str(e), "primary_action": "HOLD", "action_strength": "å¼±", "risk_assessment": "ãƒ‡ãƒ¼ã‚¿ä¸è¶³é«˜ãƒªã‚¹ã‚¯"}

    def _get_position_sizing_advice(self, action: str, risk_level: str) -> str:
        if action == "HOLD": return "ç¾çŠ¶ç¶­æŒ"
        profile_multipliers = {"conservative": 0.5, "natural": 1.0, "aggressive": 1.5}
        risk_multipliers = {"low": 1.0, "medium": 0.8, "high": 0.5}
        multiplier = profile_multipliers.get(self.current_profile, 1.0) * risk_multipliers.get(risk_level, 0.8)
        return f"è³‡é‡‘ã®{int(10 * multiplier)}%ç¨‹åº¦"

    def _get_basic_recommendations(self, action: str) -> List[str]:
        recs = {"BUY": ["ETF/ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŠ•è³‡æ¤œè¨", "ãƒ‰ãƒ«ã‚³ã‚¹ãƒˆå¹³å‡æ³•", "ç·Šæ€¥è³‡é‡‘ç¢ºä¿"],
                "SELL": ["æ®µéšçš„åˆ©ç¢ºæ¤œè¨", "ç¾é‡‘ãƒã‚¸ã‚·ãƒ§ãƒ³å¢—", "ç¨å‹™åŠ¹ç‡è€ƒæ…®"],
                "HOLD": ["ç¾ãƒã‚¸ã‚·ãƒ§ãƒ³ç¶­æŒ", "å¸‚å ´å‹•å‘ç›£è¦–", "æŠ•è³‡æ©Ÿä¼šæº–å‚™"]}
        return recs.get(action, recs["HOLD"])

    def generate_investment_advice(self) -> Dict[str, Any]:
        try:
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹ (ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile})")
            market_status = self._get_current_market_status()
            predictions, errors = self._get_ai_predictions_summary() # errors ã«ã¯MAPEæƒ…å ±ãŒå…¥ã‚‹
            tech_signals = self._get_technical_signals_summary()
            assessment = self._generate_comprehensive_market_assessment(market_status, predictions, errors, tech_signals)
            advice = self._generate_investment_advice_from_assessment(assessment)
            
            return {
                "metadata": {"generated_at": datetime.now().isoformat(), "profile": self.current_profile, "calculation_errors": self.calculation_errors},
                "market_analysis": {"current_status": market_status, "ai_predictions": predictions, 
                                    "ai_reliability": errors, # å¤‰æ•°å errors ã¯MAPEæƒ…å ±ã‚’å«ã‚€ã®ã§ãã®ã¾ã¾ä½¿ç”¨
                                    "technical_signals": tech_signals},
                "assessment": {"overall_trend": assessment.trend, "confidence_score": assessment.confidence, "risk_level": assessment.risk_level,
                               "technical_score": assessment.tech_score, "ai_reliability": assessment.ai_reliability},
                "investment_advice": advice
            }
        except Exception as e: self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}"); return {"error": str(e)}

    def generate_investment_report(self, save_to_json: bool = False, print_to_console: bool = True) -> bool:
        try:
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™")
            report_data = self.generate_investment_advice()
            if "error" in report_data: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {report_data['error']}"); return False
            
            self._log_prediction_summary() # äºˆæ¸¬ä¾¡æ ¼ã®ãƒ­ã‚°å‡ºåŠ›
            
            if print_to_console:
                # _display_enhanced_report ã¯å†…éƒ¨ã§ _extract_prediction_prices ã‚’å‘¼ã¶ã®ã§ã€
                # report_data['prediction_prices'] ã‚’äº‹å‰ã«ã‚»ãƒƒãƒˆã™ã‚‹å¿…è¦ã¯ãªã„ã€‚
                # report_data['timestamp'] ã‚‚ä¸è¦ (metadataå†…ã«ã‚ã‚‹ã‹ã€_display_enhanced_reportå†…ã§ç”Ÿæˆ)
                self._display_enhanced_report(report_data) 
            
            if save_to_json:
                # _save_report_to_json ã¯ report_data ã‚’ç›´æ¥å—ã‘å–ã‚‹
                self._save_report_to_json(report_data)
            
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”ŸæˆãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
            return True
        except Exception as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}"); return False

    def _print_report(self, data: Dict[str, Any]): # _display_enhanced_reportã«ç½®ãæ›ãˆã‚‰ã‚ŒãŸãŸã‚ã€åŸºæœ¬çš„ã«ã¯ä¸è¦
        self.logger.warning("_print_report ã¯å¤ã„ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚_display_enhanced_report ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚")
        self._display_enhanced_report(data) # äº’æ›æ€§ã®ãŸã‚ã«å‘¼ã³å‡ºã™

    def _save_report_to_json(self, report_data: Dict[str, Any]) -> bool:
        try:
            # metadataã‹ã‚‰profileåã‚’å–å¾—
            profile_name = report_data.get("metadata", {}).get("profile", self.current_profile)
            timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"investment_report_{profile_name}_{timestamp_str}.json"
            
            # äºˆæ¸¬ä¾¡æ ¼(_extract_prediction_pricesã®çµæœ)ã‚’ãƒ¬ãƒãƒ¼ãƒˆã«å«ã‚ã‚‹ (ã‚‚ã—å«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°)
            if 'prediction_prices' not in report_data: # _display_enhanced_reportç”¨ã«_extract_prediction_pricesãŒå‘¼ã°ã‚Œã‚‹ãŒã€ä¿å­˜æ™‚ã«ã‚‚ç¢ºèª
                 report_data['prediction_prices'] = self._extract_prediction_prices()

            return bool(self._save_analysis_report(report_data, filename))
        except Exception as e: self.logger.error(f"JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}"); return False

    def _save_analysis_report(self, report_data: Dict[str, Any], filename: str) -> Optional[str]:
        def clean_data(obj): # NumPy/Pandaså‹ã‚’JSONäº’æ›ã«ã™ã‚‹
            if isinstance(obj, dict): return {k: clean_data(v) for k, v in obj.items()}
            elif isinstance(obj, list): return [clean_data(v) for v in obj]
            elif pd.isna(obj): return None
            elif isinstance(obj, (np.integer, np.floating)): return float(obj) # np.bool_ ã¯jsonã§ True/False ã«ãªã‚‹
            elif isinstance(obj, pd.Timestamp): return obj.isoformat()
            return obj
        try:
            cleaned_report_data = clean_data(report_data)
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(cleaned_report_data, f, ensure_ascii=False, indent=2, default=str) # default=strã¯æœ€çµ‚æ‰‹æ®µ
            self.logger.info(f"ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜: {filename}")
            return filename
        except Exception as e: self.logger.error(f"ä¿å­˜ã‚¨ãƒ©ãƒ¼ ({filename}): {e}"); return None

    def validate_system(self) -> Dict[str, Any]:
        validation = {
            "market_data_loaded": self.sp500_df is not None and not self.sp500_df.empty,
            "ai_models_loaded": len(self.trained_models_results) > 0,
            "profile_valid": self.current_profile in UNIFIED_PROFILES, # (ä¿®æ­£5) PROFILES -> UNIFIED_PROFILES
            "config_accessible": self._get_current_config() is not None, # (ä¿®æ­£8) ã§å®Ÿè£…æ¸ˆã¿
            "ai_predictions_working": False
        }
        try:
            predictions, _ = self._get_ai_predictions_summary()
            # ã‚­ãƒ¼åçµ±ä¸€(ä¿®æ­£7) long_term ã® trend_pct ã‚’ç¢ºèª
            long_term_trend = predictions.get("long_term", {}).get("trend_pct", 0)
            validation["ai_predictions_working"] = abs(long_term_trend) > 0.001 or \
                                                 (predictions.get("nextday", {}).get("price", 0) != 0) # nextdayä¾¡æ ¼ã§ã‚‚ç¢ºèª
        except Exception: pass
        validation["overall_valid"] = all(validation.values())
        return validation
