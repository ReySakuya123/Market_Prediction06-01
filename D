def _generate_investment_advice_from_assessment(self, assessment: 'MarketAssessment') -> Dict[str, Any]:
        """ä¿®æ­£ç‰ˆ: AIäºˆæ¸¬é‡è¦–ã®æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆ"""
        try:
            config = self._get_current_config()
            confidence_threshold = config.get("confidence_threshold", 0.6)
            
            # === é‡è¤‡è¨ˆç®—ã‚’æ’é™¤ ===
            # æ—¢ã«assessmentã«å«ã¾ã‚Œã¦ã„ã‚‹AIæƒ…å ±ã‚’ä½¿ç”¨
            ai_trend = getattr(assessment, '_ai_trend', None)
            if ai_trend is None:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¿…è¦ãªå ´åˆã®ã¿è¨ˆç®—
                predictions, _ = self._get_ai_predictions_summary()
                ai_trend = predictions.get("long_term", {}).get("trend_pct", 0)
            
            ai_confidence = assessment.ai_reliability
            
            primary_action = "HOLD" # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            action_strength = "ä¸­" # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            reason = "åˆæœŸçŠ¶æ…‹" # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤

            # === AIä¿¡é ¼åº¦ãƒ™ãƒ¼ã‚¹ã®åˆ¤å®š ===
            if ai_confidence > 0.80:
                self.logger.info(f"é«˜ä¿¡é ¼åº¦AIåˆ¤å®šãƒ¢ãƒ¼ãƒ‰: AIäºˆæ¸¬={ai_trend:.2f}%, ä¿¡é ¼åº¦={ai_confidence:.1%}")
                
                if ai_trend < -3.0:
                    primary_action = "SELL"
                    action_strength = "å¼·" if ai_trend < -5.0 else "ä¸­"
                    reason = f"é«˜ä¿¡é ¼åº¦AIä¸‹è½äºˆæ¸¬({ai_trend:.1f}%)"
                elif ai_trend > 3.0:
                    primary_action = "BUY"
                    action_strength = "å¼·" if ai_trend > 5.0 else "ä¸­"
                    reason = f"é«˜ä¿¡é ¼åº¦AIä¸Šæ˜‡äºˆæ¸¬(+{ai_trend:.1f}%)"
                else:  # -3% â‰¤ ai_trend â‰¤ 3%
                    primary_action = "HOLD"
                    action_strength = "ä¸­"
                    reason = f"AIäºˆæ¸¬ãŒä¸­ç«‹ç¯„å›²({ai_trend:.1f}%)"
                
                # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã«ã‚ˆã‚‹å¾®èª¿æ•´
                if assessment.trend != "neutral":
                    if assessment.trend == "bullish" and primary_action == "SELL":
                        action_strength = "å¼±"  # å¼·åº¦ã‚’ä¸‹ã’ã‚‹
                        reason += " (ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ä¸Šæ˜‡ã§å¼·åº¦èª¿æ•´)"
                    elif assessment.trend == "bearish" and primary_action == "BUY":
                        action_strength = "å¼±"
                        reason += " (ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ä¸‹è½ã§å¼·åº¦èª¿æ•´)"
            
            else:
                # === ä½ä¿¡é ¼åº¦ã®å ´åˆã¯å¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯ ===
                self.logger.info(f"å¾“æ¥åˆ¤å®šãƒ¢ãƒ¼ãƒ‰: AIä¿¡é ¼åº¦={ai_confidence:.1%}")
                
                if assessment.confidence < confidence_threshold:
                    primary_action = "HOLD"
                    action_strength = "å¼±"
                    reason = f"ç·åˆä¿¡é ¼åº¦ä¸è¶³({assessment.confidence:.1%})"
                elif assessment.trend == "bullish" and assessment.risk_level != "high":
                    primary_action = "BUY"
                    action_strength = "ä¸­"
                    reason = "ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ä¸Šæ˜‡ãƒˆãƒ¬ãƒ³ãƒ‰"
                elif assessment.trend == "bearish":
                    primary_action = "SELL"
                    action_strength = "ä¸­"
                    reason = "ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ä¸‹é™ãƒˆãƒ¬ãƒ³ãƒ‰"
                else:
                    primary_action = "HOLD"
                    action_strength = "ä¸­"
                    reason = "æ˜ç¢ºãªãƒˆãƒ¬ãƒ³ãƒ‰ãªã—"

            # === è­¦å‘Šç”Ÿæˆ ===
            warnings: List[str] = []
            if ai_confidence > 0.80:  # é«˜ä¿¡é ¼åº¦AIäºˆæ¸¬ã®å ´åˆ
                if ai_trend < -5:
                    warnings.append(f"ğŸš¨ é«˜ä¿¡é ¼åº¦AIäºˆæ¸¬: å¤§å¹…ä¸‹è½è­¦å‘Š({ai_trend:.1f}%)")
                elif ai_trend < -2:
                    warnings.append(f"âš ï¸ é«˜ä¿¡é ¼åº¦AIäºˆæ¸¬: ä¸‹è½ãƒªã‚¹ã‚¯({ai_trend:.1f}%)")
                elif ai_trend > 5:
                    warnings.append(f"ğŸ“ˆ é«˜ä¿¡é ¼åº¦AIäºˆæ¸¬: å¤§å¹…ä¸Šæ˜‡æœŸå¾…(+{ai_trend:.1f}%)")
            
            if assessment.risk_level == "high":
                warnings.append("âš ï¸ é«˜ãƒªã‚¹ã‚¯å¸‚å ´ç’°å¢ƒ")
            if assessment.confidence < 0.4:
                warnings.append("âš ï¸ äºˆæ¸¬ä¿¡é ¼åº¦ãŒä½ä¸‹")

            warnings.extend([
                "æŠ•è³‡ã¯å…ƒæœ¬ä¿è¨¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä½™è£•è³‡é‡‘ã§ã®æŠ•è³‡ã‚’å¿ƒãŒã‘ã¦ãã ã•ã„ã€‚",
                "ã“ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã¯æƒ…å ±æä¾›ç›®çš„ã§ã‚ã‚Šã€æŠ•è³‡ã®æœ€çµ‚åˆ¤æ–­ã¯ã”è‡ªèº«ã§è¡Œã£ã¦ãã ã•ã„ã€‚"
            ])

            return {
                "primary_action": primary_action,
                "action_strength": action_strength,
                "risk_assessment": f"{assessment.risk_level}ãƒªã‚¹ã‚¯",
                "confidence_score": assessment.confidence,
                "profile_adjusted_advice": {
                    "advice_text": f"ã€{self.current_profile.upper()}ã€‘{primary_action}æ¨å¥¨ï¼ˆ{action_strength}ï¼‰- {reason}",
                    "position_sizing": self._get_position_sizing_advice(primary_action, assessment.risk_level)
                },
                "key_factors": [
                    f"AIäºˆæ¸¬: {ai_trend:+.1f}% (ä¿¡é ¼åº¦: {ai_confidence:.1%})",
                    f"å¸‚å ´ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.trend}",
                    f"ç·åˆä¿¡é ¼åº¦: {assessment.confidence:.1%}",
                    f"ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«: {assessment.risk_level}",
                    f"åˆ¤å®šãƒ¢ãƒ¼ãƒ‰: {'AIå„ªå…ˆ' if ai_confidence > 0.80 else 'å¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯'}"
                ],
                "recommendations": self._get_basic_recommendations(primary_action),
                "warnings": warnings[:5] # è­¦å‘Šã¯æœ€å¤§5ä»¶
            }

        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {
                "error": str(e),
                "primary_action": "HOLD",
                "action_strength": "å¼±",
                "risk_assessment": "ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã‚Šé«˜ãƒªã‚¹ã‚¯"
            }

from dataclasses import dataclass # MarketAssessment ã®ä»®å®šç¾©ç”¨
import logging # ãƒ­ã‚¬ãƒ¼ç”¨

# MarketAssessment ã‚¯ãƒ©ã‚¹ã®ä»®å®šç¾©ï¼ˆå®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å®šç¾©ã«ç½®ãæ›ãˆã¦ãã ã•ã„ï¼‰
@dataclass
class MarketAssessment:
    trend: str
    confidence: float
    risk_level: str
    tech_score: float
    ai_reliability: float

class InvestmentStrategy: # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå±ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã®ä»®å
    def __init__(self):
        # self.logger ã®åˆæœŸåŒ–ã®ä¾‹ (å®Ÿéš›ã®ãƒ­ã‚¬ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„)
        self.logger = logging.getLogger(__name__)
        # ç°¡å˜ãªãƒ†ã‚¹ãƒˆã®ãŸã‚ã«æ¨™æº–å‡ºåŠ›ã«ãƒ­ã‚°ã‚’å‡ºã™è¨­å®š
        if not self.logger.hasHandlers(): # é‡è¤‡ã—ã¦ãƒãƒ³ãƒ‰ãƒ©ãŒè¿½åŠ ã•ã‚Œã‚‹ã®ã‚’é˜²ã
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)

    # --- ä¿®æ­£ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ ---
    def _create_market_assessment_internal(self, trend: str, final_confidence: float, risk_level: str, tech_score: float, ai_reliability_param: float) -> 'MarketAssessment':
        """
        ç·åˆå¸‚å ´è©•ä¾¡ã‚’ç”Ÿæˆã™ã‚‹å†…éƒ¨é–¢æ•°ã€‚
        å…ƒã®ã‚³ãƒ¼ãƒ‰ã® `ai_reliability = final_confidence` ã¨ã„ã†è¡Œã¨ã€
        MarketAssessmentã®å¼•æ•°ã‹ã‚‰ã€final_confidence ãŒç·åˆçš„ãªä¿¡é ¼åº¦ã§ã€
        ai_reliability_param ãŒAIå›ºæœ‰ã®ä¿¡é ¼åº¦ã¨è§£é‡ˆã€‚
        """
        try:
            # confidenceã¯0.1ã‹ã‚‰0.9ã®ç¯„å›²ã«åã‚ã‚‹
            clipped_confidence = max(0.1, min(0.9, final_confidence))

            # MarketAssessmentã‚¯ãƒ©ã‚¹ã®å®Ÿéš›ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã«åˆã‚ã›ã¦ãã ã•ã„
            # MarketAssessmentã®å‹å®šç¾©ãŒã‚ã‚Œã°ã€ä»¥ä¸‹ã® # type: ignore ã‚³ãƒ¡ãƒ³ãƒˆã¯ä¸è¦ã§ã™
            result = MarketAssessment(
                trend=trend,
                confidence=clipped_confidence,
                risk_level=risk_level,
                tech_score=tech_score,
                ai_reliability=ai_reliability_param
            )
            self.logger.info(f"ç·åˆè©•ä¾¡: {trend}, ä¿¡é ¼åº¦={result.confidence:.2f}, ãƒªã‚¹ã‚¯={risk_level}, AIä¿¡é ¼åº¦={result.ai_reliability:.2f}")
            return result

        except Exception as e:
            self.logger.error(f"ç·åˆå¸‚å ´è©•ä¾¡ã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}", exc_info=True)
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
            # MarketAssessmentã®å‹å®šç¾©ãŒã‚ã‚Œã°ã€ä»¥ä¸‹ã® # type: ignore ã‚³ãƒ¡ãƒ³ãƒˆã¯ä¸è¦ã§ã™
            return MarketAssessment(
                trend="neutral",
                confidence=0.5,
                risk_level="medium",
                tech_score=0.5,
                ai_reliability=0.5
            )


    def generate_investment_advice(self) -> Dict[str, Any]:
        """ä¿®æ­£ç‰ˆ: é‡è¤‡è¨ˆç®—ã‚’æ’é™¤ã—ãŸæŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆ"""
        try:
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹ (ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile})")

            # === ä¸€åº¦ã ã‘ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— ===
            market_status = self._get_current_market_status()
            predictions, model_errors = self._get_ai_predictions_summary()  # ä¸€åº¦ã ã‘å®Ÿè¡Œ
            tech_signals = self._get_technical_signals_summary()

            # === AIäºˆæ¸¬æƒ…å ±ã‚’assessmentã«æ¸¡ã™ãŸã‚ä¸€æ™‚ä¿å­˜ ===
            ai_trend = predictions.get("long_term", {}).get("trend_pct", 0.0) # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’floatã«

            assessment = self._generate_comprehensive_market_assessment(
                market_status, predictions, model_errors, tech_signals
            )

            # AIäºˆæ¸¬æƒ…å ±ã‚’assessmentã«è¿½åŠ ï¼ˆé‡è¤‡è¨ˆç®—å›é¿ï¼‰
            # MarketAssessmentã‚¯ãƒ©ã‚¹ãŒã“ã®å±æ€§ã‚’è¨±å®¹ã™ã‚‹ã‚ˆã†ã«æ³¨æ„
            assessment._ai_trend = ai_trend

            advice = self._generate_investment_advice_from_assessment(assessment)

            return {
                "metadata": {
                    "generated_at": datetime.now().isoformat(),
                    "profile": self.current_profile,
                    "calculation_errors": self.calculation_errors # self.calculation_errorsãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å‰æ
                },
                "market_analysis": {
                    "current_status": market_status,
                    "ai_predictions": predictions,
                    "model_reliability": model_errors,
                    "technical_signals": tech_signals
                },
                "assessment": {
                    "overall_trend": assessment.trend,
                    "confidence_score": assessment.confidence,
                    "risk_level": assessment.risk_level,
                    "technical_score": assessment.tech_score,
                    "ai_reliability": assessment.ai_reliability
                },
                "investment_advice": advice
            }

        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True) # exc_info=True ã‚’è¿½åŠ 
            return {"error": str(e)}


    def generate_investment_report(self, save_to_json: bool = False, print_to_console: bool = True) -> bool:
        """æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        try:
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™")
            report_data = self.generate_investment_advice()
            
            if "error" in report_data:
                self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {report_data['error']}")
                return False
            
            # äºˆæ¸¬ä¾¡æ ¼ã®ãƒ­ã‚°å‡ºåŠ›ã‚’è¿½åŠ 
            self._log_prediction_summary()
            
            # ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º
            if print_to_console:
                self._display_enhanced_report(report_data)
            
            # JSONä¿å­˜
            if save_to_json:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"investment_report_{timestamp}.json"
                
                try:
                    with open(filename, 'w', encoding='utf-8') as f:
                        json.dump(report_data, f, ensure_ascii=False, indent=2, default=str)
                    self.logger.info(f"æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆã‚’ {filename} ã«ä¿å­˜ã—ã¾ã—ãŸ")
                except Exception as e:
                    self.logger.error(f"JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†")
            return True
            
        except Exception as e:
            self.logger.error(f"æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _display_enhanced_report(self, report_data: Dict[str, Any]):
        """å¼·åŒ–ã•ã‚ŒãŸãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º"""
        prediction_prices = self._extract_prediction_prices()
        
        print("\n" + "="*60)
        print("        ğŸ¯ AIæŠ•è³‡åˆ†æãƒ¬ãƒãƒ¼ãƒˆï¼ˆå¼·åŒ–ç‰ˆï¼‰ ğŸ¯")
        print("="*60)
        print(f"ğŸ“… ç”Ÿæˆæ—¥æ™‚: {report_data.get('metadata', {}).get('generated_at', 'N/A')}")
        print(f"ğŸ‘¤ æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile.upper()}")
        
        # AIäºˆæ¸¬ä¾¡æ ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
        print("\nğŸ”® ã€AIäºˆæ¸¬ä¾¡æ ¼ã€‘")
        if 'nextday' in prediction_prices:
            print(f"ç¿Œæ—¥äºˆæ¸¬: ${prediction_prices['nextday']['price']:,.2f}")
        if 'short' in prediction_prices:
            print(f"çŸ­æœŸäºˆæ¸¬ï¼ˆ20æ—¥å¾Œï¼‰: ${prediction_prices['short']['price']:,.2f}")
        if 'long' in prediction_prices:
            print(f"é•·æœŸäºˆæ¸¬ï¼ˆ30æ—¥å¾Œï¼‰: ${prediction_prices['long']['price']:,.2f}")
        
        # æ—¢å­˜ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        assessment = report_data.get("assessment", {})
        advice = report_data.get("investment_advice", {})
        market = report_data.get("market_analysis", {}).get("current_status", {})
        ai_predictions = report_data.get("market_analysis", {}).get("ai_predictions", {})
        
        long_term = ai_predictions.get("long_term", {})
        ai_trend = long_term.get("trend_pct", 0)
        ai_confidence = long_term.get("confidence", 0)
        
        print(f"\nğŸ¤– ã€AIäºˆæ¸¬åˆ†æã€‘")
        print(f"é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬: {ai_trend:+.2f}%")
        print(f"AIä¿¡é ¼åº¦: {ai_confidence:.1%}")
        
        print(f"\nğŸ“Š ã€ç·åˆè©•ä¾¡ã€‘")
        print(f"ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.get('overall_trend', 'N/A').upper()}")
        print(f"ä¿¡é ¼åº¦: {assessment.get('confidence_score', 0):.1%}")
        print(f"ãƒªã‚¹ã‚¯: {assessment.get('risk_level', 'N/A').upper()}")
        print(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢: {assessment.get('technical_score', 0):.2f}")
        print(f"AIä¿¡é ¼åº¦: {assessment.get('ai_reliability', 0):.1%}")
        
        print(f"\nğŸ’¡ ã€æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€‘")
        print(f"ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {advice.get('primary_action', 'N/A')}")
        print(f"å¼·åº¦: {advice.get('action_strength', 'N/A')}")
        
        profile_advice = advice.get("profile_adjusted_advice", {})
        if profile_advice:
            print(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¹: {profile_advice.get('advice_text', 'N/A')}")
            print(f"æ¨å¥¨ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚º: {profile_advice.get('position_sizing', 'N/A')}")
        
        key_factors = advice.get("key_factors", [])
        if key_factors:
            print(f"\nğŸ” ã€ä¸»è¦åˆ¤æ–­è¦å› ã€‘")
            for factor in key_factors:
                print(f"â€¢ {factor}")
        
        warnings = advice.get("warnings", [])
        if warnings:
            print(f"\nâš ï¸ ã€è­¦å‘Šãƒ»æ³¨æ„äº‹é …ã€‘")
            for i, warning in enumerate(warnings[:3], 1):
                print(f"{i}. {warning}")
        
        if market and "error" not in market:
            print(f"\nğŸ“ˆ ã€å¸‚å ´çŠ¶æ³ã€‘")
            print(f"S&P500ä¾¡æ ¼: ${market.get('current_price', 0):.2f}")
            print(f"æ—¥æ¬¡å¤‰å‹•: {market.get('daily_change', 0):+.2f}%")
            print(f"VIXæŒ‡æ•°: {market.get('VIX', 0):.1f} ({market.get('vix_level', 'N/A')})")
            print(f"5æ—¥ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£: {market.get('volatility_5d', 0):.1f}%")
        
        print("="*60)

    def _debug_ai_predictions_detailed(self):
        """AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒ‡ãƒãƒƒã‚°ï¼ˆæœ¬ç•ªç’°å¢ƒå¯¾å¿œç‰ˆï¼‰"""
        self.logger.debug("=== AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿è©³ç´°åˆ†æ ===")
        for model_key, model_result in self.trained_models_results.items():
            self.logger.debug(f"\n--- {model_key}ãƒ¢ãƒ‡ãƒ«è©³ç´° ---")
            if isinstance(model_result, dict):
                for key, value in model_result.items():
                    try:
                        if isinstance(value, list):
                            if len(value) > 0:
                                self.logger.debug(f"  {key}: List[{len(value)}] - æœ€å¾Œã®3ã¤: {value[-3:]}")
                            else:
                                self.logger.debug(f"  {key}: ç©ºã®ãƒªã‚¹ãƒˆ")
                        elif isinstance(value, (int, float)):
                            self.logger.debug(f"  {key}: {value}")
                        else:
                            self.logger.debug(f"  {key}: {type(value)}")
                    except Exception as e:
                        self.logger.debug(f"  {key}: ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚¨ãƒ©ãƒ¼ - {e}")
                
                # ç‰¹ã«é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒã‚§ãƒƒã‚¯
                try:
                    if 'y_pred_original_test' in model_result and 'y_test_original_test' in model_result:
                        pred = model_result['y_pred_original_test']
                        actual = model_result['y_test_original_test']
                        if isinstance(pred, list) and isinstance(actual, list):
                            self.logger.debug(f"  äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿é•·: {len(pred)}, å®Ÿéš›ãƒ‡ãƒ¼ã‚¿é•·: {len(actual)}")
                            if len(pred) > 0 and len(actual) > 0:
                                self.logger.debug(f"  æœ€å¾Œã®äºˆæ¸¬å€¤: {pred[-1]}, æœ€å¾Œã®å®Ÿéš›å€¤: {actual[-1]}")
                    
                    if 'latest_prediction_original' in model_result:
                        latest = model_result['latest_prediction_original']
                        self.logger.debug(f"  æœ€æ–°äºˆæ¸¬å€¤: {latest}")
                except Exception as e:
                    self.logger.debug(f"  é‡è¦ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")



    
    def _save_report_to_json(self, report_data: Dict[str, Any]) -> bool:
        try:
            filename = f"investment_report_{self.current_profile}_{datetime.now():%Y%m%d_%H%M%S}.json"
            return bool(self._save_analysis_report(report_data, filename))
        except Exception as e:
            self.logger.error(f"JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _save_analysis_report(self, report_data: Dict[str, Any], filename: str) -> Optional[str]:
        def clean_data(obj):
            if isinstance(obj, dict):
                return {k: clean_data(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [clean_data(v) for v in obj]
            elif pd.isna(obj): # np.isnan ã¯æ•°å€¤ã®ã¿, pd.isna ã¯ã‚ˆã‚Šåºƒç¯„
                return None # JSONã§ã¯NaNã¯éæ¨™æº–ãªã®ã§Noneã«
            elif isinstance(obj, (np.integer, np.floating)):
                return float(obj)
            elif isinstance(obj, pd.Timestamp):
                return obj.isoformat()
            return obj
        
        try:
            cleaned_report_data = clean_data(report_data) # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(cleaned_report_data, f, ensure_ascii=False, indent=2, default=str)
            self.logger.info(f"ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜: {filename}")
            return filename
        except Exception as e:
            self.logger.error(f"ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def validate_system(self) -> Dict[str, Any]:
        validation = {
            "market_data_loaded": self.sp500_df is not None and not self.sp500_df.empty,
            "ai_models_loaded": len(self.trained_models_results) > 0,
            "profile_valid": self.current_profile in self.PROFILES,
            "config_accessible": self._get_current_config() is not None,
            "ai_predictions_working": False  # ã“ã‚Œã‚’ãƒã‚§ãƒƒã‚¯
        }
        
        # AIäºˆæ¸¬ã®å‹•ä½œç¢ºèª
        try:
            predictions, _ = self._get_ai_predictions_summary()
            long_term_trend = predictions.get("long_term", {}).get("trend_pct", 0)
            validation["ai_predictions_working"] = abs(long_term_trend) > 0.001 # ã‚¼ãƒ­ã§ãªã„ã“ã¨ã‚’ç¢ºèª
        except Exception: # è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯çœç•¥
            pass
        
        validation["overall_valid"] = all(validation.values())
        return validation


class MarketPredictionSystem:
    """é‡‘èå¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹"""

    def __init__(
        self, config_file: str = "config.json", advisor_config_file: str = "advisor_config.json",
        logger_manager: LoggerManager = APP_LOGGER_MANAGER, # å¤–éƒ¨ã‹ã‚‰LoggerManagerã‚’æ³¨å…¥å¯èƒ½ã«
        reuse_hyperparams_on_init: bool = False,
        data_source_type: str = "api" # "api" or "csv"
    ):
        self.logger_manager = logger_manager
        self.logger = self.logger_manager.get_logger(self.__class__.__name__)
        self.logger.info(f"ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹ã€‚ãƒ¡ã‚¤ãƒ³è¨­å®š: {config_file}, ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼è¨­å®š: {advisor_config_file}, ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹: {data_source_type}")

        self.config = Config(config_file, logger_manager=self.logger_manager)

        # HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ (DataFetcher APIç”¨)
        self.http_session: Optional[Any] = None # CurlSessionã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        if CurlSession: # ã‚°ãƒ­ãƒ¼ãƒãƒ«CurlSessionãŒå®šç¾©ã•ã‚Œã¦ã„ã‚Œã°
            try:
                if CurlSession.__module__.startswith("curl_cffi"):
                    self.http_session = CurlSession(impersonate="chrome110")
                    self.logger.info("HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ã« curl_cffi.requests.Session ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
                else:
                    self.http_session = CurlSession()
                    self.logger.info("HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ã« requests.Session ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
            except Exception as e:
                self.logger.warning(f"ã‚°ãƒ­ãƒ¼ãƒãƒ«CurlSessionã‹ã‚‰ã®HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã«å¤±æ•—: {e}")
        else:
            self.logger.warning("CurlSessionã‚¨ã‚¤ãƒªã‚¢ã‚¹ãŒæœªå®šç¾©ã€‚APIãƒ™ãƒ¼ã‚¹ã®DataFetcherã¯HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ãªã—ã§å‹•ä½œã—ã¾ã™ã€‚")

        # ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ£ãƒ¼ã®é¸æŠ
        self.data_source_type = data_source_type.lower()
        if self.data_source_type == "csv":
            self.data_fetcher: Union[CSVDataFetcher, DataFetcher] = CSVDataFetcher(self.config, self.logger_manager)
            self.logger.info("CSVDataFetcher ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
        elif self.data_source_type == "api":
            self.data_fetcher = DataFetcher(self.config, self.logger_manager, session=self.http_session)
            self.logger.info("DataFetcher (APIãƒ™ãƒ¼ã‚¹) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
        else:
            self.logger.error(f"ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—: {data_source_type}ã€‚'api' ã¾ãŸã¯ 'csv' ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚APIã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¾ã™ã€‚")
            self.data_fetcher = DataFetcher(self.config, self.logger_manager, session=self.http_session) # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

        self.feature_engineering = FeatureEngineering(self.config, self.logger_manager)
        self.lstm_model = LSTMModel(self.config, self.logger_manager)
        self.visualizer = MarketVisualizer(self.config, self.logger_manager)
        self.advisor_config_file = advisor_config_file # InvestmentAdvisoråˆæœŸåŒ–æ™‚ã«æ¸¡ã™

        if reuse_hyperparams_on_init:
            self.lstm_model.load_best_params()

        self.market_data_store: Dict[str, Any] = {}
        self.trained_models_store: Dict[str, Any] = {}


    def run(
        self, force_hyperparam_optimization: bool = False,
        optimization_n_trials: Optional[int] = None,
        generate_report_profile: str = "natural"
    ) -> bool:
        self.logger.info(f"ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œé–‹å§‹ã€‚æœ€é©åŒ–å¼·åˆ¶:{force_hyperparam_optimization}, Optunaè©¦è¡Œ:{optimization_n_trials or 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ'}, ãƒ¬ãƒãƒ¼ãƒˆãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«:{generate_report_profile}")
        run_start_time = datetime.now()
        overall_success = False
        try:
            # 1. ãƒ‡ãƒ¼ã‚¿å–å¾—
            self.logger.info("--- ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ ---")
            self.market_data_store = self.data_fetcher.fetch_all_indexes()
            if not self.market_data_store or "^GSPC" not in self.market_data_store or self.market_data_store["^GSPC"]["df"].empty:
                self.logger.critical("ä¸»è¦å¸‚å ´ãƒ‡ãƒ¼ã‚¿(S&P500)å–å¾—å¤±æ•—ã€‚ã‚·ã‚¹ãƒ†ãƒ ç¶šè¡Œä¸å¯ã€‚")
                return False
            self.logger.info("ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 2. ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°
            self.logger.info("--- ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ ---")
            self.market_data_store = self.feature_engineering.add_technical_indicators(self.market_data_store)
            self.logger.info("ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 3. ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ– (S&P500å¯¾è±¡)
            if force_hyperparam_optimization or (not self.lstm_model.best_params and self.lstm_model.load_best_params() is False) : # ãƒ­ãƒ¼ãƒ‰è©¦è¡Œã—ã¦ãƒ€ãƒ¡ãªã‚‰
                self.logger.info("--- LSTMãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
                if "^GSPC" in self.market_data_store and not self.market_data_store["^GSPC"]["df"].empty:
                    self.lstm_model.optimize_hyperparameters(self.market_data_store, target_ticker="^GSPC", n_trials=optimization_n_trials)
                else: self.logger.warning("S&P500ãƒ‡ãƒ¼ã‚¿ä¸ååˆ†ã§æœ€é©åŒ–ã‚¹ã‚­ãƒƒãƒ—ã€‚")
                self.logger.info("ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")
            else: self.logger.info("æ—¢å­˜ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½¿ç”¨ã¾ãŸã¯æœ€é©åŒ–è¦æ±‚ãªã—ã€‚")

            # 4. LSTMãƒ¢ãƒ‡ãƒ«å­¦ç¿’ (S&P500å¯¾è±¡)
            self.logger.info("--- LSTMãƒ¢ãƒ‡ãƒ«å­¦ç¿’ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
            if "^GSPC" in self.market_data_store and not self.market_data_store["^GSPC"]["df"].empty:
                if not self.lstm_model.best_params: self.lstm_model.load_best_params() # å†åº¦ãƒ­ãƒ¼ãƒ‰è©¦è¡Œ
                self.trained_models_store = self.lstm_model.train_models_for_sp500(self.market_data_store)
            else: self.logger.error("S&P500ãƒ‡ãƒ¼ã‚¿ä¸ååˆ†ã§LSTMå­¦ç¿’ã‚¹ã‚­ãƒƒãƒ—ã€‚")
            self.logger.info("LSTMãƒ¢ãƒ‡ãƒ«å­¦ç¿’ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 5. å¯è¦–åŒ– (S&P500å¯¾è±¡)
            self.logger.info("--- å¯è¦–åŒ–ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
            if "^GSPC" in self.market_data_store and self.trained_models_store:
                graph_path = self.visualizer.plot_predictions_for_sp500(self.market_data_store, self.trained_models_store)
                if graph_path: self.logger.info(f"åˆ†æã‚°ãƒ©ãƒ•ã‚’ {graph_path} ã«ä¿å­˜ã€‚")
                else: self.logger.warning("ã‚°ãƒ©ãƒ•ç”Ÿæˆ/ä¿å­˜å¤±æ•—ã€‚")
            else: self.logger.warning("S&P500ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯å­¦ç¿’æ¸ˆãƒ¢ãƒ‡ãƒ«ãªã—ã€‚å¯è¦–åŒ–ã‚¹ã‚­ãƒƒãƒ—ã€‚")
            self.logger.info("å¯è¦–åŒ–ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")

            # 6. æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆ (S&P500å¯¾è±¡)
            self.logger.info("--- æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹ (S&P500) ---")
            if "^GSPC" in self.market_data_store and self.trained_models_store:
                advisor = InvestmentAdvisor(
                    self.market_data_store, self.trained_models_store, self.logger_manager,
                    self.advisor_config_file, generate_report_profile
                )
                if not advisor.generate_investment_advice():
                    self.logger.warning("æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå¤±æ•—ã€‚")
            else: self.logger.warning("S&P500ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯å­¦ç¿’æ¸ˆãƒ¢ãƒ‡ãƒ«ãªã—ã€‚æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¹ã‚­ãƒƒãƒ—ã€‚")
            self.logger.info("æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã€‚")
            overall_success = True

        except KeyboardInterrupt:
            self.logger.warning("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚Šå‡¦ç†ãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸã€‚")
        except Exception as e:
            self.logger.critical(f"ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œä¸­ã«è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
        finally:
            self.logger_manager.save_performance_log() # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ­ã‚°ä¿å­˜
            duration_sec = (datetime.now() - run_start_time).total_seconds()
            self.logger.info(f"å¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ å…¨å‡¦ç†çµ‚äº†ã€‚æ‰€è¦æ™‚é–“: {duration_sec:.2f}ç§’ã€‚æˆåŠŸ: {overall_success}")
        return overall_success


# --- Jupyter Notebook / ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œã®ãŸã‚ã®ãƒ¡ã‚¤ãƒ³å‡¦ç†éƒ¨åˆ† ---
if __name__ == "__main__":
    # ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªLoggerManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ç”¨
    main_logger = APP_LOGGER_MANAGER.get_logger("MainExecution")
    main_logger.info("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œé–‹å§‹ã€‚")

    # --- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ (å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´) ---
    main_config_path = "config.json"
    advisor_config_path = "advisor_config.json"
    # config.jsonã®ã‚µãƒ³ãƒ—ãƒ« (ä¸Šè¨˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å‚è€ƒã«ä½œæˆã—ã¦ãã ã•ã„)
    # advisor_config.jsonã®ã‚µãƒ³ãƒ—ãƒ« (ä¸Šè¨˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å‚è€ƒã«ä½œæˆã—ã¦ãã ã•ã„)

    # Jupyter Notebookç’°å¢ƒã‹ã©ã†ã‹ã§UIã‚’åˆ†å²
    is_jupyter = False
    try:
        # Jupyterç’°å¢ƒã§ã®ã¿æˆåŠŸã™ã‚‹ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        from IPython import get_ipython
        if get_ipython() is not None and 'IPKernelApp' in get_ipython().config:
            is_jupyter = True
            import ipywidgets as widgets
            from IPython.display import display, clear_output
            main_logger.info("Jupyter Notebookç’°å¢ƒã‚’æ¤œå‡ºã€‚ipywidgets UIã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
    except ImportError:
        main_logger.info("Jupyter Notebookç’°å¢ƒã§ã¯ãªã„ã‹ã€ipywidgetsãŒã‚ã‚Šã¾ã›ã‚“ã€‚CUIãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œã—ã¾ã™ã€‚")


    if is_jupyter:
        # --- Jupyter UI ---
        data_source_selector_ui = widgets.ToggleButtons(
            options=[('API (yfinance)', 'api'), ('ãƒ­ãƒ¼ã‚«ãƒ«CSV', 'csv')], description='ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹:', value='api',
            style={'button_width': 'auto'}, tooltips=['yfinanceçµŒç”±ã§æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—', 'äº‹å‰ã«ç”¨æ„ã—ãŸCSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨']
        )
        hyperparam_mode_selector_ui = widgets.ToggleButtons(
            options=[('æ–°è¦æœ€é©åŒ–', 'optimize'), ('ä¿å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æµç”¨', 'reuse')], description='ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:', value='reuse',
            style={'button_width': 'auto'}
        )
        optuna_trials_input_ui = widgets.IntText(
            value=APP_LOGGER_MANAGER.get_logger("UI_Config").info("Optunaè©¦è¡Œå›æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯Configã‹ã‚‰å–å¾—ã‚’æ¨å¥¨") or 5, # configã‹ã‚‰å–å¾—ã—ãŸã„
            description='Optunaè©¦è¡Œå›æ•°:', disabled=(hyperparam_mode_selector_ui.value == 'reuse')
        )
        def handle_hyperparam_mode_change(change): optuna_trials_input_ui.disabled = (change.new == 'reuse')
        hyperparam_mode_selector_ui.observe(handle_hyperparam_mode_change, names='value')

        # ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¯AdvisorConfigLoaderã‹ã‚‰å‹•çš„ã«å–å¾—ã—ãŸã„
        # ã“ã“ã§ã¯ä»®ã®ãƒªã‚¹ãƒˆã‚’ä½¿ç”¨ã€‚ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œæ™‚ã«AdvisorConfigLoaderãŒåˆæœŸåŒ–ã•ã‚Œã‚‹ã®ã§ã€ãã®æ™‚ç‚¹ã§å–å¾—ã™ã‚‹ã®ãŒç†æƒ³
        temp_advisor_loader = AdvisorConfigLoader(advisor_config_path, APP_LOGGER_MANAGER)
        profile_options_ui = [(p.capitalize(), p) for p in temp_advisor_loader.get_profile_list()]
        if not profile_options_ui: profile_options_ui = [('Natural', 'natural')] # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

        advisor_profile_selector_ui = widgets.Dropdown(
            options=profile_options_ui, value=profile_options_ui[0][1] if profile_options_ui else 'natural',
            description='æŠ•è³‡åˆ¤æ–­ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«:', style={'description_width': 'initial'}
        )
        run_button_ui = widgets.Button(description='å¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œ', button_style='success', icon='cogs')
        output_area_ui = widgets.Output()

        display(data_source_selector_ui, hyperparam_mode_selector_ui, optuna_trials_input_ui, advisor_profile_selector_ui, run_button_ui, output_area_ui)

        def on_run_button_clicked_ui(b):
            with output_area_ui:
                clear_output(wait=True)
                main_logger.info("--- UIã‹ã‚‰ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œé–‹å§‹ ---")
                data_src = data_source_selector_ui.value
                force_opt = (hyperparam_mode_selector_ui.value == 'optimize')
                opt_trials = optuna_trials_input_ui.value if force_opt else None
                report_prof = advisor_profile_selector_ui.value

                system = MarketPredictionSystem(
                    main_config_path, advisor_config_path, APP_LOGGER_MANAGER,
                    reuse_hyperparams_on_init=(not force_opt), data_source_type=data_src
                )
                success = system.run(force_opt, opt_trials, report_prof)
                print(f"\nğŸ‰ ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œ {'æ­£å¸¸å®Œäº†' if success else 'ã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ'} ğŸ‰" if success else "\nğŸ’¥ ã‚·ã‚¹ãƒ†ãƒ å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ ğŸ’¥")
        run_button_ui.on_click(on_run_button_clicked_ui)

    else:
        # --- CUIãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ ---
        print("="*30 + "\né‡‘èå¸‚å ´äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ  (CUIãƒ¢ãƒ¼ãƒ‰)\n" + "="*30)
        ds_input = input("ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’é¸æŠ [api, csv] (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: api): ").strip().lower() or "api"
        mode_input = input("ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠ [optimize, reuse] (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: reuse): ").strip().lower() or "reuse"
        force_opt_cui = (mode_input == "optimize")
        opt_trials_cui_val = None
        if force_opt_cui:
            try: opt_trials_cui_val = int(input("Optunaè©¦è¡Œå›æ•°ã‚’å…¥åŠ› (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 5): ").strip() or "5")
            except ValueError: opt_trials_cui_val = 5

        # ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« (CUI)
        temp_advisor_loader_cui = AdvisorConfigLoader(advisor_config_path, APP_LOGGER_MANAGER)
        profiles_cui = temp_advisor_loader_cui.get_profile_list()
        profile_prompt = f"æŠ•è³‡åˆ¤æ–­ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ [{', '.join(profiles_cui)}] (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: {profiles_cui[0] if profiles_cui else 'natural'}): "
        profile_input_cui = input(profile_prompt).strip().lower() or (profiles_cui[0] if profiles_cui else 'natural')
        if profile_input_cui not in profiles_cui and profiles_cui : profile_input_cui = profiles_cui[0] # ä¸æ­£å…¥åŠ›æ™‚ã¯å…ˆé ­

        system_cui = MarketPredictionSystem(
            main_config_path, advisor_config_path, APP_LOGGER_MANAGER,
            reuse_hyperparams_on_init=(not force_opt_cui), data_source_type=ds_input
        )
        system_cui.run(force_opt_cui, opt_trials_cui_val, profile_input_cui)

    main_logger.info("ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œçµ‚äº†ã€‚")
