class AdvisorConfigLoader:
    """æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ç”¨è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ãƒ»ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    DEFAULT_ADVISOR_CONFIG = {
        "report_filename_template": "market_analysis_report_{profile}.json", # ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«ã‚‚å¯èƒ½
        "profiles": {
            "natural": {
                "profile_description": "æ¨™æº–çš„ãªãƒãƒ©ãƒ³ã‚¹å‹ã€‚åŸºæœ¬é–¾å€¤ã§ã‚·ã‚°ãƒŠãƒ«åˆ¤å®šã€‚",
                "signal_thresholds": {"buy": 2, "sell": 2}, "vix_threshold": 25,
                "short_trend_threshold_pct": 0.5, "error_accept_threshold_pct": 8.0
            },
            "aggressive": {
                "profile_description": "ç©æ¥µå‹ã€‚è²·ã„é–¾å€¤ä½ã‚ã€VIXè¨±å®¹é«˜ã‚ã€‚",
                "signal_thresholds": {"buy": 1, "sell": 3}, "vix_threshold": 30,
                "short_trend_threshold_pct": 0.2, "error_accept_threshold_pct": 10.0
            },
            "passive": {
                "profile_description": "æ…é‡å‹ã€‚è²·ã„é–¾å€¤é«˜ã‚ã€VIXè¨±å®¹ä½ã‚ã€‚",
                "signal_thresholds": {"buy": 3, "sell": 1}, "vix_threshold": 20,
                "short_trend_threshold_pct": 1.0, "error_accept_threshold_pct": 6.0
            },
        },
        "technical_analysis_settings": { # æ—§ technical_analysis
            "buy_signal_columns": ["golden_cross", "RSI_buy_signal", "MACD_buy_signal", "BB_buy_signal"],
            "sell_signal_columns": ["death_cross", "RSI_sell_signal", "MACD_sell_signal", "BB_sell_signal"],
            "recent_days_for_signal_count": 5,
            "ma_cross_signal_recency_days": 10
        },
    }

    def __init__(self, config_path: str = "advisor_config.json", logger_manager: Optional[LoggerManager] = None):
        self.logger = (logger_manager or APP_LOGGER_MANAGER).get_logger(self.__class__.__name__)
        self.config_path = config_path
        # Configã‚¯ãƒ©ã‚¹ã® _deep_update ã¨ _load_config ã‚’å€Ÿç”¨ (ã¾ãŸã¯å…±é€šåŒ–)
        temp_main_config_loader = Config() # ãƒ€ãƒŸãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãƒ¡ã‚½ãƒƒãƒ‰åˆ©ç”¨
        self.config_data = temp_main_config_loader._load_config(config_path) # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ¸¡ã•ãªã„
        # Advisorã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’é©ç”¨
        self.config_data = temp_main_config_loader._deep_update(self.DEFAULT_ADVISOR_CONFIG.copy(), self.config_data)

        self.current_profile_name = "natural" # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        self.set_profile(self.current_profile_name)
        self.logger.info(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼è¨­å®šã‚’ '{config_path}' ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã€‚ç¾åœ¨ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile_name}")


    def set_profile(self, profile_name: str) -> bool:
        profiles = self.config_data.get("profiles", {})
        if profile_name in profiles:
            self.current_profile_name = profile_name
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ '{profile_name}' ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚")
            return True
        else:
            self.logger.warning(f"ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« '{profile_name}' ã¯è¨­å®šã«å­˜åœ¨ã—ã¾ã›ã‚“ã€‚'{self.current_profile_name}' ã‚’ç¶­æŒã—ã¾ã™ã€‚")
            return False

    def get_profile_list(self) -> List[str]: return list(self.config_data.get("profiles", {}).keys())
    def get_current_profile_config(self) -> Dict[str, Any]: return self.config_data.get("profiles", {}).get(self.current_profile_name, {})
    def get_profile_description(self) -> str: return self.get_current_profile_config().get("profile_description", "èª¬æ˜ãªã—")

    def get_config_value(self, key_path: str, default: Optional[Any] = None) -> Any:
        keys = key_path.split('.')
        # 1. ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰è¨­å®š
        val = self.get_current_profile_config()
        for key in keys:
            if isinstance(val, dict) and key in val: val = val[key]
            else: val = None; break # è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°Noneã«ã—ã¦å…±é€šè¨­å®šã¸
        if val is not None: return val
        # 2. å…±é€šè¨­å®š
        val_common = self.config_data
        for key in keys:
            if isinstance(val_common, dict) and key in val_common: val_common = val_common[key]
            else: return default # å…±é€šã«ã‚‚ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return val_common


class MarketDataAnalyzer:
    """å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æã®ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ç¾¤"""
    
    def __init__(self, logger_manager: Optional[LoggerManager] = None):
        self.logger = (logger_manager or APP_LOGGER_MANAGER).get_logger(self.__class__.__name__)
    
    @staticmethod
    def get_nested_value(data: dict, keys: list, default=None):
        """ãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã‹ã‚‰å€¤ã‚’å®‰å…¨ã«å–å¾—"""
        for key in keys:
            if isinstance(data, dict) and key in data:
                data = data[key]
            else:
                return default
        return data
    
    def find_last_signal_date(self, df: pd.DataFrame, signal_column_name: str) -> Optional[pd.Timestamp]:
        """æŒ‡å®šã•ã‚ŒãŸã‚·ã‚°ãƒŠãƒ«åˆ—ã®æœ€å¾Œã®ç™ºç”Ÿæ—¥ã‚’æ¤œç´¢"""
        if signal_column_name not in df.columns or df[signal_column_name].dtype != 'bool':
            self.logger.debug(f"ã‚·ã‚°ãƒŠãƒ«åˆ— '{signal_column_name}' ä¸åœ¨ã¾ãŸã¯éboolå‹ã€‚")
            return None
        try:
            true_signals = df.loc[df[signal_column_name]]  # .loc ã§ FutureWarning å›é¿
            return pd.Timestamp(true_signals.index.max()) if not true_signals.empty else None
        except Exception as e:
            self.logger.warning(f"'{signal_column_name}' æœ€çµ‚ã‚·ã‚°ãƒŠãƒ«æ—¥æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return None
    
    def is_date_within_recent_days(self, latest_market_date: pd.Timestamp,
                                   target_event_date: Optional[pd.Timestamp], recent_days_threshold: int) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ãŒæœ€è¿‘ã®é–¾å€¤æ—¥æ•°ä»¥å†…ã‹ã‚’åˆ¤å®š"""
        if target_event_date is None:
            return False
        if not (isinstance(latest_market_date, pd.Timestamp) and isinstance(target_event_date, pd.Timestamp)):
            self.logger.warning("is_date_within_recent_days: æ—¥ä»˜ãŒTimestampå‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚")
            return False
        return (latest_market_date - target_event_date).days <= recent_days_threshold
    
    def calculate_trend_percentage(self, prediction_array: Any, period_name: str = "æœŸé–“", 
                                  current_market_price: Optional[float] = None) -> float:
        """
        äºˆæ¸¬é…åˆ—ã‹ã‚‰ç¾åœ¨ä¾¡æ ¼ã‚’åŸºæº–ã¨ã—ãŸãƒˆãƒ¬ãƒ³ãƒ‰%ã‚’è¨ˆç®—
        
        Args:
            prediction_array: äºˆæ¸¬ä¾¡æ ¼ã®é…åˆ—
            period_name: ãƒ­ã‚°ç”¨ã®æœŸé–“å
            current_market_price: ç¾åœ¨ã®å¸‚å ´ä¾¡æ ¼ï¼ˆåŸºæº–ä¾¡æ ¼ï¼‰
        
        Returns:
            float: ãƒˆãƒ¬ãƒ³ãƒ‰% (æ­£=ä¸Šæ˜‡ã€è² =ä¸‹é™)
        """
        try:
            # ãƒ‡ãƒ¼ã‚¿å‹ã®çµ±ä¸€
            if isinstance(prediction_array, pd.Series):
                values = prediction_array.dropna().values
            elif isinstance(prediction_array, np.ndarray):
                values = prediction_array.flatten()
            elif isinstance(prediction_array, list):
                values = np.array([v for v in prediction_array if v is not None and not np.isnan(v)])
            else:
                self.logger.warning(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: æœªå¯¾å¿œå‹ {type(prediction_array)}")
                return 0.0
            
            if len(values) < 1:
                self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: ãƒ‡ãƒ¼ã‚¿ç‚¹ä¸è¶³ ({len(values)})")
                return 0.0
            
            # åŸºæº–ä¾¡æ ¼ã®æ±ºå®šï¼ˆç¾åœ¨ä¾¡æ ¼ > äºˆæ¸¬ã®æœ€åˆã®å€¤ï¼‰
            if current_market_price is not None and current_market_price > 0:
                base_price = current_market_price
            else:
                base_price = values[0]
            
            # çµ‚äº†ä¾¡æ ¼ï¼ˆäºˆæ¸¬ã®æœ€å¾Œã®å€¤ï¼‰
            end_price = values[-1]
            
            # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if base_price <= 0 or np.isnan(base_price) or np.isnan(end_price):
                self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: ç„¡åŠ¹ãªä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ (base: {base_price}, end: {end_price})")
                return 0.0
            
            # ãƒˆãƒ¬ãƒ³ãƒ‰%è¨ˆç®—ï¼ˆæ­£=ä¸Šæ˜‡ã€è² =ä¸‹é™ï¼‰
            trend_pct = ((end_price - base_price) / base_price) * 100
            
            self.logger.debug(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—: {base_price:.2f} â†’ {end_price:.2f} = {trend_pct:.2f}%")
            
            return float(trend_pct)
            
        except Exception as e:
            self.logger.warning(f"{period_name}ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return 0.0
    
    def get_sp500_dataframe(self, market_data_dict: Dict[str, Dict[str, Any]]) -> Optional[pd.DataFrame]:
        """å¸‚å ´ãƒ‡ãƒ¼ã‚¿è¾æ›¸ã‹ã‚‰S&P500 DataFrameã‚’å–å¾—"""
        sp500_entry = market_data_dict.get("^GSPC")
        if not sp500_entry or "df" not in sp500_entry or sp500_entry["df"].empty:
            self.logger.error("S&P500 DataFrameãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ç©ºã§ã™ã€‚")
            return None
        return sp500_entry["df"]

class ReportGenerator:
    """ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆï¼ˆJSONä¿å­˜ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ï¼‰"""
    def __init__(self, logger_manager: Optional[LoggerManager] = None):
        self.logger = (logger_manager or APP_LOGGER_MANAGER).get_logger(self.__class__.__name__)

    def save_report_to_json(self, report_data: Dict[str, Any], filename: str):
        self.logger.info(f"åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ '{filename}' ã«ä¿å­˜è©¦è¡Œ...")
        try:
            save_dir = os.path.dirname(filename)
            if save_dir and not os.path.exists(save_dir): os.makedirs(save_dir)
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False, default=str) # default=strã§datetimeç­‰ã«å¯¾å¿œ
            self.logger.info(f"åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ '{filename}' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
        except IOError as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆ '{filename}' ä¿å­˜IOã‚¨ãƒ©ãƒ¼: {e}")
        except Exception as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆ '{filename}' ä¿å­˜ä¸­äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)


    def print_basic_report_to_console(self, report_data: Dict[str, Any]):
        if not report_data: self.logger.warning("è¡¨ç¤ºã™ã‚‹ãƒ¬ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚"); return
        try:
            print("\n" + "="*10 + " ğŸ“ˆ S&P500 ç©ç«‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ†æãƒ¬ãƒãƒ¼ãƒˆ ğŸ“‰ " + "="*10)
            print(f"åˆ†ææ—¥æ™‚: {report_data.get('analysis_datetime', 'N/A')}")
            print(f"æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {report_data.get('profile_name', 'æœªè¨­å®š')} ({report_data.get('profile_description', 'N/A')})")
            print("-" * 60)

            status = report_data.get('market_status', {})
            print(f"â–  S&P500 ç¾çŠ¶:")
            print(f"  - æœ€æ–°ä¾¡æ ¼ ({status.get('last_price_date', 'N/A')}): {status.get('current_price', 0.0):.2f}")
            if "VIX" in status: print(f"  - VIXæŒ‡æ•°: {status['VIX']:.2f}")

            preds = report_data.get('ai_predictions', {})
            errors = report_data.get('ai_error_rates', {})
            print("\nâ–  AIä¾¡æ ¼äºˆæ¸¬ (LSTM):")
            if "nextday_price" in preds:
                print(f"  - ç¿Œæ—¥äºˆæ¸¬: {preds['nextday_price']:.2f} (MAPE: {errors.get('nextday_mape', 0.0):.2f}%)")
            short_p = preds.get('short_term', {})
            if "end_price" in short_p:
                print(f"  - çŸ­æœŸ({short_p.get('days',0)}æ—¥å¾Œ): {short_p['end_price']:.2f} (ãƒˆãƒ¬ãƒ³ãƒ‰: {short_p.get('trend_pct', 0.0):.2f}%, MAPE: {errors.get('short_mape',0.0):.2f}%)")
            long_p = preds.get('long_term', {})
            if "end_price" in long_p:
                print(f"  - é•·æœŸ({long_p.get('days',0)}æ—¥å¾Œ): {long_p['end_price']:.2f} (ãƒˆãƒ¬ãƒ³ãƒ‰: {long_p.get('trend_pct', 0.0):.2f}%, MAPE: {errors.get('long_mape',0.0):.2f}%)")

            tech = report_data.get('technical_signals', {})
            print("\nâ–  ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚µãƒãƒªãƒ¼:")
            print(f"  - MAã‚¯ãƒ­ã‚¹: {tech.get('ma_cross_status', 'æƒ…å ±ãªã—')}")
            recent_days = tech.get('recent_days_for_count',0)
            print(f"  - ç›´è¿‘{recent_days}æ—¥ã®ã‚·ã‚°ãƒŠãƒ«:")
            buy_c = tech.get('buy_signal_counts', {})
            sell_c = tech.get('sell_signal_counts', {})
            buy_str = ', '.join([f'{k.replace("_signal","")}:{v}' for k,v in buy_c.items() if v>0]) or "ãªã—"
            sell_str = ', '.join([f'{k.replace("_signal","")}:{v}' for k,v in sell_c.items() if v>0]) or "ãªã—"
            print(f"    è²·ã„ã‚·ã‚°ãƒŠãƒ«åˆè¨ˆ: {tech.get('total_buy_score',0)} ({buy_str})")
            print(f"    å£²ã‚Šã‚·ã‚°ãƒŠãƒ«åˆè¨ˆ: {tech.get('total_sell_score',0)} ({sell_str})")

            print("-" * 60)
            print(f"â–  ç·åˆç©ç«‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹:\n  {report_data.get('overall_advice', 'åˆ¤æ–­ææ–™ä¸è¶³')}")
            print("-" * 60 + "\n")
        except Exception as e: self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
