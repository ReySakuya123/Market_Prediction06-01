@dataclass
class MarketAssessment:
    """å¸‚å ´è©•ä¾¡ã®ç·åˆçµæœ"""
    trend: str
    confidence: float
    risk_level: str
    tech_score: float
    ai_reliability: float

class InvestmentAdvisor:
    """AIäºˆæ¸¬ä¿®æ­£ç‰ˆæŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼"""
    
    PROFILES = {
        "natural": {"buy_threshold": 3, "vix_threshold": 25, "ai_weight": 2.0},
        "aggressive": {"buy_threshold": 2, "vix_threshold": 30, "ai_weight": 1.5},
        "conservative": {"buy_threshold": 5, "vix_threshold": 20, "ai_weight": 3.0}
    }

    def __init__(self, market_data_dict: Dict, trained_models_results: Dict, 
                 logger_manager: LoggerManager, advisor_config_file: str = "advisor_config.json", 
                 initial_profile_name: str = "natural"):
        self.logger = logger_manager.get_logger(self.__class__.__name__)
        self.market_data_dict = market_data_dict
        self.trained_models_results = trained_models_results
        self.current_profile = initial_profile_name
        self.profile = self.PROFILES.get(initial_profile_name, self.PROFILES["natural"])
        self.sp500_df = self._get_sp500_data()
        self.calculation_errors = []
        
        # ãƒ‡ãƒãƒƒã‚°æƒ…å ±å‡ºåŠ›
        self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªå¸‚å ´ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ¼: {list(self.market_data_dict.keys())}")
        self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«çµæœã‚­ãƒ¼: {list(self.trained_models_results.keys())}")
        
        # AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒ‡ãƒãƒƒã‚°
        self._debug_ai_predictions_detailed()
        
        self.builtin_config = {
            "conservative": {"buy_threshold": 5, "vix_threshold": 20, "ai_weight": 3.0, "confidence_threshold": 0.8},
            "natural": {"buy_threshold": 3, "vix_threshold": 25, "ai_weight": 2.0, "confidence_threshold": 0.6},
            "aggressive": {"buy_threshold": 2, "vix_threshold": 30, "ai_weight": 1.5, "confidence_threshold": 0.4}
        }
        
        self.logger.info(f"InvestmentAdvisoråˆæœŸåŒ–å®Œäº† - ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile}")

    def _extract_prediction_prices(self):
        """å„ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ä¾¡æ ¼ã‚’æŠ½å‡º"""
        prediction_prices = {}
        
        try:
            # nextdayãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ä¾¡æ ¼
            if 'nextday' in self.trained_models_results:
                nextday_result = self.trained_models_results['nextday']
                if 'latest_prediction_original' in nextday_result:
                    nextday_pred = nextday_result['latest_prediction_original']
                    if isinstance(nextday_pred, (list, np.ndarray)) and len(nextday_pred) > 0:
                        prediction_prices['nextday'] = {
                            'price': round(float(nextday_pred[0]), 2),
                            'period': 'ç¿Œæ—¥'
                        }
                    elif isinstance(nextday_pred, (int, float)):
                        prediction_prices['nextday'] = {
                            'price': round(float(nextday_pred), 2),
                            'period': 'ç¿Œæ—¥'
                        }
            
            # shortãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ä¾¡æ ¼ï¼ˆæœ€çµ‚æ—¥ï¼‰
            if 'short' in self.trained_models_results:
                short_result = self.trained_models_results['short']
                if 'latest_prediction_original' in short_result:
                    short_pred = short_result['latest_prediction_original']
                    if isinstance(short_pred, (list, np.ndarray)) and len(short_pred) > 0:
                        prediction_prices['short'] = {
                            'price': round(float(short_pred[-1]), 2),
                            'period': '20æ—¥å¾Œ'
                        }
            
            # longãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ä¾¡æ ¼ï¼ˆæœ€çµ‚æ—¥ï¼‰
            if 'long' in self.trained_models_results:
                long_result = self.trained_models_results['long']
                if 'latest_prediction_original' in long_result:
                    long_pred = long_result['latest_prediction_original']
                    if isinstance(long_pred, (list, np.ndarray)) and len(long_pred) > 0:
                        # ğŸ”§ æ”¹å–„1: é•·æœŸäºˆæ¸¬ã®å®‰å®šåŒ–å‡¦ç†ã‚’é©ç”¨
                        raw_long_price = self._extract_long_term_prediction(long_pred)
                        
                        # ğŸ”§ æ”¹å–„2: ç¾åœ¨ä¾¡æ ¼ã‚’å–å¾—ã—ã¦å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                        current_price = self.sp500_df['Close'].iloc[-1] if not self.sp500_df.empty else 5900
                        validated_long_price = self._validate_prediction(current_price, raw_long_price, 'long')
                        
                        prediction_prices['long'] = {
                            'price': round(float(validated_long_price), 2),
                            'period': '30æ—¥å¾Œ'  # ğŸ”§ æ”¹å–„3: 100æ—¥å¾Œâ†’30æ—¥å¾Œã«å¤‰æ›´ï¼ˆã‚ˆã‚Šç¾å®Ÿçš„ï¼‰
                        }
                        
            self.logger.info(f"äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºå®Œäº†: {prediction_prices}")
            return prediction_prices
            
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬ä¾¡æ ¼æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _extract_long_term_prediction(self, long_pred_array):
        """é•·æœŸäºˆæ¸¬ã®å®‰å®šåŒ– - ãƒã‚¤ã‚ºå‰Šæ¸›ã®ãŸã‚æœ€å¾Œã®æœŸé–“ã®å¹³å‡ã‚’ä½¿ç”¨"""
        try:
            if isinstance(long_pred_array, (list, np.ndarray)) and len(long_pred_array) > 20:
                # æœ€å¾Œã®20æ—¥é–“ã®å¹³å‡ã‚’å–ã‚‹ï¼ˆæ¥µç«¯ãªå€¤ã‚’é¿ã‘ã‚‹ï¼‰
                stable_pred = np.mean(long_pred_array[-20:])
                original_pred = long_pred_array[-1]
                self.logger.debug(f"é•·æœŸäºˆæ¸¬å®‰å®šåŒ–: å…ƒå€¤={original_pred:.2f} â†’ å®‰å®šåŒ–å€¤={stable_pred:.2f}")
                return stable_pred
            elif len(long_pred_array) > 0:
                return long_pred_array[-1]
            else:
                self.logger.warning("é•·æœŸäºˆæ¸¬é…åˆ—ãŒç©ºã§ã™")
                return 0
        except Exception as e:
            self.logger.error(f"é•·æœŸäºˆæ¸¬æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return long_pred_array[-1] if len(long_pred_array) > 0 else 0

    def _validate_prediction(self, current_price: float, predicted_price: float, prediction_type: str) -> float:
        """äºˆæ¸¬å€¤ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ç•°å¸¸å€¤ã‚’è£œæ­£"""
        try:
            change_pct = ((predicted_price - current_price) / current_price) * 100
            
            # å¦¥å½“æ€§ã®é–¾å€¤è¨­å®šï¼ˆæœŸé–“åˆ¥ï¼‰
            thresholds = {
                'nextday': (-5, 5),    # Â±5%ä»¥å†…
                'short': (-15, 15),    # Â±15%ä»¥å†…  
                'long': (-25, 25)      # Â±25%ä»¥å†…
            }
            
            min_change, max_change = thresholds.get(prediction_type, (-30, 30))
            
            if change_pct < min_change or change_pct > max_change:
                self.logger.warning(f"{prediction_type}äºˆæ¸¬ãŒç•°å¸¸å€¤: {change_pct:.2f}% â†’ è£œæ­£å®Ÿè¡Œ")
                # ç•°å¸¸å€¤ã®å ´åˆã¯é–¾å€¤å†…ã«è£œæ­£
                corrected_change = np.sign(change_pct) * min(abs(change_pct), abs(max_change))
                corrected_price = current_price * (1 + corrected_change / 100)
                self.logger.info(f"{prediction_type}äºˆæ¸¬è£œæ­£: {predicted_price:.2f} â†’ {corrected_price:.2f}")
                return corrected_price
            
            self.logger.debug(f"{prediction_type}äºˆæ¸¬ã¯å¦¥å½“ç¯„å›²å†…: {change_pct:.2f}%")
            return predicted_price
            
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬å€¤æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return current_price  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç¾åœ¨ä¾¡æ ¼ã‚’è¿”ã™

    def _log_prediction_summary(self):
        """äºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ã‚’ãƒ­ã‚°å‡ºåŠ›"""
        try:
            prediction_prices = self._extract_prediction_prices()
            
            self.logger.info("=== AIäºˆæ¸¬ä¾¡æ ¼ã‚µãƒãƒªãƒ¼ ===")
            for model_name, pred_data in prediction_prices.items():
                self.logger.info(f"{model_name}ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ä¾¡æ ¼: ${pred_data['price']:,.2f} ({pred_data['period']})")
            
            # ç¾åœ¨ä¾¡æ ¼ã¨ã®æ¯”è¼ƒ
            if not self.sp500_df.empty:
                current_price = self.sp500_df['Close'].iloc[-1]
                self.logger.info(f"ç¾åœ¨ä¾¡æ ¼: ${current_price:,.2f}")
                
                if 'nextday' in prediction_prices:
                    change = prediction_prices['nextday']['price'] - current_price
                    change_pct = (change / current_price) * 100
                    self.logger.info(f"ç¿Œæ—¥äºˆæ¸¬å¤‰åŒ–: ${change:+.2f} ({change_pct:+.2f}%)")
                    
        except Exception as e:
            self.logger.error(f"äºˆæ¸¬ã‚µãƒãƒªãƒ¼ãƒ­ã‚°ã‚¨ãƒ©ãƒ¼: {e}")

    def _display_enhanced_report(self, report_data: Dict[str, Any]):
        """å¼·åŒ–ã•ã‚ŒãŸãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º"""
        prediction_prices = self._extract_prediction_prices()
        
        print("\n" + "="*60)
        print("        ğŸ¯ AIæŠ•è³‡åˆ†æãƒ¬ãƒãƒ¼ãƒˆï¼ˆå¼·åŒ–ç‰ˆï¼‰ ğŸ¯")
        print("="*60)
        print(f"ğŸ“… ç”Ÿæˆæ—¥æ™‚: {report_data.get('timestamp', 'N/A')}")
        print(f"ğŸ‘¤ æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile.upper()}")
        
        # AIäºˆæ¸¬ä¾¡æ ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
        print("\nğŸ”® ã€AIäºˆæ¸¬ä¾¡æ ¼ã€‘")
        if 'nextday' in prediction_prices:
            print(f"ç¿Œæ—¥äºˆæ¸¬: ${prediction_prices['nextday']['price']:,.2f}")
        if 'short' in prediction_prices:
            print(f"çŸ­æœŸäºˆæ¸¬ï¼ˆ20æ—¥å¾Œï¼‰: ${prediction_prices['short']['price']:,.2f}")
        if 'long' in prediction_prices:
            print(f"é•·æœŸäºˆæ¸¬ï¼ˆ30æ—¥å¾Œï¼‰: ${prediction_prices['long']['price']:,.2f}") # ä¿®æ­£: 100æ—¥å¾Œâ†’30æ—¥å¾Œ
        
        # æ—¢å­˜ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        assessment = report_data.get("assessment", {})
        advice = report_data.get("investment_advice", {})
        market = report_data.get("market_analysis", {}).get("current_status", {})
        ai_predictions = report_data.get("market_analysis", {}).get("ai_predictions", {})
        
        long_term = ai_predictions.get("long_term", {})
        ai_trend = long_term.get("trend_pct", 0)
        ai_confidence = long_term.get("confidence", 0)
        
        print(f"\nğŸ¤– ã€AIäºˆæ¸¬åˆ†æã€‘")
        print(f"é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬: {ai_trend:+.2f}%")
        print(f"AIä¿¡é ¼åº¦: {ai_confidence:.1%}")
        
        print(f"\nğŸ“Š ã€ç·åˆè©•ä¾¡ã€‘")
        print(f"ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.get('overall_trend', 'N/A').upper()}")
        print(f"ä¿¡é ¼åº¦: {assessment.get('confidence_score', 0):.1%}")
        print(f"ãƒªã‚¹ã‚¯: {assessment.get('risk_level', 'N/A').upper()}")
        print(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢: {assessment.get('technical_score', 0):.2f}")
        print(f"AIä¿¡é ¼åº¦: {assessment.get('ai_reliability', 0):.1%}")
        
        print(f"\nğŸ’¡ ã€æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€‘")
        print(f"ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {advice.get('primary_action', 'N/A')}")
        print(f"å¼·åº¦: {advice.get('action_strength', 'N/A')}")
        
        profile_advice = advice.get("profile_adjusted_advice", {})
        if profile_advice:
            print(f"ã‚¢ãƒ‰ãƒã‚¤ã‚¹: {profile_advice.get('advice_text', 'N/A')}")
            print(f"æ¨å¥¨ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚º: {profile_advice.get('position_sizing', 'N/A')}")
        
        key_factors = advice.get("key_factors", [])
        if key_factors:
            print(f"\nğŸ” ã€ä¸»è¦åˆ¤æ–­è¦å› ã€‘")
            for factor in key_factors:
                print(f"â€¢ {factor}")
        
        warnings = advice.get("warnings", [])
        if warnings:
            print(f"\nâš ï¸ ã€è­¦å‘Šãƒ»æ³¨æ„äº‹é …ã€‘")
            for i, warning in enumerate(warnings[:3], 1):
                print(f"{i}. {warning}")
        
        if market and "error" not in market:
            print(f"\nğŸ“ˆ ã€å¸‚å ´çŠ¶æ³ã€‘")
            print(f"S&P500ä¾¡æ ¼: ${market.get('current_price', 0):.2f}")
            print(f"æ—¥æ¬¡å¤‰å‹•: {market.get('daily_change', 0):+.2f}%")
            print(f"VIXæŒ‡æ•°: {market.get('VIX', 0):.1f} ({market.get('vix_level', 'N/A')})")
            print(f"5æ—¥ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£: {market.get('volatility_5d', 0):.1f}%")
        
        print("="*60)

    def _debug_ai_predictions_detailed(self):
        """AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒ‡ãƒãƒƒã‚°"""
        self.logger.info("=== AIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿è©³ç´°åˆ†æ ===")
        for model_key, model_result in self.trained_models_results.items():
            self.logger.info(f"\n--- {model_key}ãƒ¢ãƒ‡ãƒ«è©³ç´° ---")
            if isinstance(model_result, dict):
                for key, value in model_result.items():
                    if isinstance(value, list):
                        if len(value) > 0:
                            self.logger.info(f"  {key}: List[{len(value)}] - æœ€å¾Œã®3ã¤: {value[-3:]}")
                        else:
                            self.logger.info(f"  {key}: ç©ºã®ãƒªã‚¹ãƒˆ")
                    elif isinstance(value, (int, float)):
                        self.logger.info(f"  {key}: {value}")
                    else:
                        self.logger.info(f"  {key}: {type(value)}")
                
                # ç‰¹ã«é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒã‚§ãƒƒã‚¯
                if 'y_pred_original_test' in model_result and 'y_test_original_test' in model_result:
                    pred = model_result['y_pred_original_test']
                    actual = model_result['y_test_original_test']
                    if isinstance(pred, list) and isinstance(actual, list):
                        self.logger.info(f"  äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿é•·: {len(pred)}, å®Ÿéš›ãƒ‡ãƒ¼ã‚¿é•·: {len(actual)}")
                        if len(pred) > 0 and len(actual) > 0:
                            self.logger.info(f"  æœ€å¾Œã®äºˆæ¸¬å€¤: {pred[-1]}, æœ€å¾Œã®å®Ÿéš›å€¤: {actual[-1]}")
                
                if 'latest_prediction_original' in model_result:
                    latest = model_result['latest_prediction_original']
                    self.logger.info(f"  æœ€æ–°äºˆæ¸¬å€¤: {latest}")

    def _get_sp500_data(self) -> Optional[pd.DataFrame]:
        """S&P500ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«å–å¾—"""
        try:
            for key in ["^GSPC", "SP500", "SPX", "sp500"]:
                if key in self.market_data_dict:
                    data = self.market_data_dict[key]
                    if isinstance(data, dict) and "df" in data:
                        df = data["df"]
                        if df is not None and not df.empty:
                            self.logger.info(f"S&P500ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ: {len(df)}è¡Œ, åˆ—: {list(df.columns)}")
                            return df
                    elif isinstance(data, pd.DataFrame) and not data.empty:
                        self.logger.info(f"S&P500ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æˆåŠŸ: {len(data)}è¡Œ, åˆ—: {list(data.columns)}")
                        return data
            
            self.logger.error("S&P500ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return pd.DataFrame()
        except Exception as e:
            self.logger.error(f"S&P500ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return pd.DataFrame()

    # --- ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä¿®æ­£ï¼š_calculate_dynamic_confidence ã‚’ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦æ­£ã—ã„ä½ç½®ã«ç§»å‹• ---
    def _calculate_dynamic_confidence(self, mape: float, model_type: str) -> float:
        """MAPEã¨ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã«åŸºã¥ãå‹•çš„ä¿¡é ¼åº¦è¨ˆç®—"""
        # ãƒ™ãƒ¼ã‚¹ä¿¡é ¼åº¦ï¼ˆMAPEãƒ™ãƒ¼ã‚¹ï¼‰
        base_confidence = max(0.1, min(0.95, (100 - mape) / 100))
        
        # ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—åˆ¥èª¿æ•´
        type_multiplier = {
            'nextday': 1.0,    # çŸ­æœŸäºˆæ¸¬ã¯æ¯”è¼ƒçš„ä¿¡é ¼æ€§é«˜
            'short': 0.9,      # ä¸­æœŸäºˆæ¸¬ã¯å°‘ã—ä½ä¸‹
            'long': 0.8        # é•·æœŸäºˆæ¸¬ã¯æ›´ã«ä½ä¸‹
        }.get(model_type, 0.8)
        
        # æœ€çµ‚ä¿¡é ¼åº¦
        final_confidence = base_confidence * type_multiplier
        
        self.logger.debug(f"{model_type}ä¿¡é ¼åº¦: MAPE={mape:.2f}% â†’ ãƒ™ãƒ¼ã‚¹={base_confidence:.2f} â†’ æœ€çµ‚={final_confidence:.2f}")
        return max(0.1, min(0.9, final_confidence))

    def _calculate_ai_prediction_from_model_data(self, model_result: Dict, model_type: str) -> tuple[float, float]:
        """ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å®Ÿéš›ã®AIäºˆæ¸¬ã‚’è¨ˆç®—"""
        try:
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: latest_prediction_originalãŒã‚ã‚‹å ´åˆ
            if 'latest_prediction_original' in model_result:
                latest_pred = model_result['latest_prediction_original']
                if isinstance(latest_pred, (list, np.ndarray)) and len(latest_pred) > 0:
                    latest_pred = latest_pred[0] if model_type == 'nextday' else latest_pred[-1]
                
                if isinstance(latest_pred, (int, float)) and latest_pred != 0:
                    # ç¾åœ¨ã®ä¾¡æ ¼ã‚’å–å¾—
                    current_price = self.sp500_df['Close'].iloc[-1] if not self.sp500_df.empty else latest_pred
                    
                    # å¤‰åŒ–ç‡è¨ˆç®—
                    change_pct = ((latest_pred - current_price) / current_price) * 100
                    
                    # ä¿¡é ¼åº¦è¨ˆç®—ï¼ˆMAPEã‹ã‚‰ï¼‰
                    mape = model_result.get('mape_test', 50)
                    # --- ã“ã“ã§ _calculate_dynamic_confidence ã‚’å‘¼ã³å‡ºã™ ---
                    confidence = self._calculate_dynamic_confidence(mape, model_type)
                    
                    self.logger.info(f"{model_type}: æœ€æ–°äºˆæ¸¬={latest_pred:.2f}, ç¾åœ¨ä¾¡æ ¼={current_price:.2f}, å¤‰åŒ–ç‡={change_pct:.2f}%, MAPE={mape:.2f}%")
                    return change_pct, confidence
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: y_pred_original_testã¨y_test_original_testã‹ã‚‰è¨ˆç®—
            if 'y_pred_original_test' in model_result and 'y_test_original_test' in model_result:
                pred_data = model_result['y_pred_original_test']
                actual_data = model_result['y_test_original_test']
                
                if isinstance(pred_data, list) and isinstance(actual_data, list) and len(pred_data) > 0 and len(actual_data) > 0:
                    # æœ€æ–°ã®äºˆæ¸¬ã¨å®Ÿéš›ã®å€¤
                    latest_pred = pred_data[-1]
                    latest_actual = actual_data[-1] if len(actual_data) > 0 else latest_pred
                    
                    # å¤‰åŒ–ç‡è¨ˆç®—
                    if latest_actual != 0:
                        change_pct = ((latest_pred - latest_actual) / latest_actual) * 100
                    else:
                        change_pct = 0
                    
                    # ä¿¡é ¼åº¦è¨ˆç®—ï¼ˆMAPEã‹ã‚‰ï¼‰
                    mape = model_result.get('mape_test', 50)
                    # --- ã“ã“ã§ _calculate_dynamic_confidence ã‚’å‘¼ã³å‡ºã™ (å¿…è¦ã«å¿œã˜ã¦) ---
                    # ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯å…ƒã®ä¿¡é ¼åº¦è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ãŒç•°ãªã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã€
                    # å¿…è¦ã§ã‚ã‚Œã° _calculate_dynamic_confidence ã‚’é©ç”¨ã™ã‚‹ã‹ã€æ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒã™ã‚‹
                    confidence = self._calculate_dynamic_confidence(mape, model_type) # ã“ã“ã‚‚é©ç”¨ã™ã‚‹å ´åˆ
                    # confidence = max(0.1, min(0.9, (100 - mape) / 100)) # å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯
                    
                    self.logger.info(f"{model_type}: äºˆæ¸¬={latest_pred:.2f}, å®Ÿéš›={latest_actual:.2f}, å¤‰åŒ–ç‡={change_pct:.2f}%, MAPE={mape:.2f}%")
                    return change_pct, confidence
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³3: predict_stepã‚’ä½¿ç”¨ã—ãŸå°†æ¥äºˆæ¸¬
            if 'predict_step' in model_result:
                predict_step_val = model_result['predict_step'] # å¤‰æ•°åã‚’å¤‰æ›´ (predict_step ã¨ã®è¡çªå›é¿)
                current_price = self.sp500_df['Close'].iloc[-1] if not self.sp500_df.empty else 5800
                
                # ç°¡æ˜“çš„ãªäºˆæ¸¬ï¼ˆå®Ÿéš›ã®ãƒ¢ãƒ‡ãƒ«ãƒ­ã‚¸ãƒƒã‚¯ã«åŸºã¥ã„ã¦èª¿æ•´ãŒå¿…è¦ï¼‰
                # ã“ã“ã§ã¯éå»ã®ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ™ãƒ¼ã‚¹ã®äºˆæ¸¬ã‚’è¡Œã†
                if not self.sp500_df.empty and len(self.sp500_df) >= predict_step_val:
                    past_returns = self.sp500_df['Close'].pct_change().dropna().tail(predict_step_val)
                    avg_return = past_returns.mean()
                    predicted_price = current_price * (1 + avg_return * predict_step_val)
                    change_pct = ((predicted_price - current_price) / current_price) * 100
                    
                    mape = model_result.get('mape_test', 30)
                    # --- ã“ã“ã§ _calculate_dynamic_confidence ã‚’å‘¼ã³å‡ºã™ (å¿…è¦ã«å¿œã˜ã¦) ---
                    confidence = self._calculate_dynamic_confidence(mape, model_type) # ã“ã“ã‚‚é©ç”¨ã™ã‚‹å ´åˆ
                    # confidence = max(0.1, min(0.9, (100 - mape) / 100)) # å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯
                    
                    self.logger.info(f"{model_type}: æ®µéšäºˆæ¸¬={predict_step_val}, å¤‰åŒ–ç‡={change_pct:.2f}%, MAPE={mape:.2f}%")
                    return change_pct, confidence
            
            self.logger.warning(f"{model_type}: äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è¨ˆç®—ã«å¤±æ•—")
            return 0.0, 0.5
            
        except Exception as e:
            self.logger.error(f"{model_type} AIäºˆæ¸¬è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return 0.0, 0.5

    @lru_cache(maxsize=1)
    def _get_ai_predictions_summary(self) -> tuple[Dict[str, Any], Dict[str, Any]]:
        """AIäºˆæ¸¬ã®ã‚µãƒãƒªãƒ¼ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ç‰ˆï¼‰"""
        predictions = {}
        errors = {}
        
        try:
            self.logger.info("=== AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼ç”Ÿæˆé–‹å§‹ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ç‰ˆï¼‰ ===")
            
            # å„ãƒ¢ãƒ‡ãƒ«ã®çµæœã‚’å€‹åˆ¥ã«å‡¦ç†
            for model_key, model_result in self.trained_models_results.items():
                if not isinstance(model_result, dict):
                    continue
                
                self.logger.debug(f"å‡¦ç†ä¸­ã®ãƒ¢ãƒ‡ãƒ«: {model_key}") # INFOã‹ã‚‰DEBUGã«å¤‰æ›´
                
                # AIäºˆæ¸¬ã‚’è¨ˆç®—
                trend_pct, confidence = self._calculate_ai_prediction_from_model_data(model_result, model_key)
                
                # MAPEå–å¾—
                mape = model_result.get('mape_test', 50)
                errors[f"{model_key}_mape"] = mape
                
                # ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—åˆ¥ã«åˆ†é¡
                if 'long' in model_key.lower():
                    predictions["long_term"] = {"trend_pct": trend_pct, "confidence": confidence}
                elif 'short' in model_key.lower():
                    predictions["short_term"] = {"trend_pct": trend_pct, "confidence": confidence}
                elif 'nextday' in model_key.lower() or 'next' in model_key.lower():
                    predictions["nextday_price"] = {"change_pct": trend_pct, "confidence": confidence}
                else:
                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯é•·æœŸã¨ã—ã¦æ‰±ã†
                    predictions["long_term"] = {"trend_pct": trend_pct, "confidence": confidence}
            
            # äºˆæ¸¬ãŒç©ºã®å ´åˆã®å‡¦ç†
            if not predictions.get("long_term"):
                # æœ€ã‚‚ä¿¡é ¼ã§ãã‚‹ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰é•·æœŸäºˆæ¸¬ã‚’ç”Ÿæˆ
                best_model = None
                best_mape = float('inf')
                
                for model_key, model_result in self.trained_models_results.items():
                    if isinstance(model_result, dict) and 'mape_test' in model_result:
                        mape = model_result.get('mape_test', 100)
                        if mape < best_mape:
                            best_mape = mape
                            best_model = model_key
                
                if best_model:
                    trend_pct, confidence = self._calculate_ai_prediction_from_model_data(
                        self.trained_models_results[best_model], best_model
                    )
                    predictions["long_term"] = {"trend_pct": trend_pct, "confidence": confidence}
                    self.logger.info(f"æœ€è‰¯ãƒ¢ãƒ‡ãƒ« {best_model} ã‹ã‚‰é•·æœŸäºˆæ¸¬ç”Ÿæˆ: {trend_pct:.2f}%")
            
            self.logger.info(f"æœ€çµ‚çš„ãªAIäºˆæ¸¬: {predictions}")
            return predictions, errors
            
        except Exception as e:
            self.logger.error(f"AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {}, {}

    def _get_vix_value(self) -> float:
        """VIXå€¤ã‚’å–å¾—ï¼ˆS&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç›´æ¥å–å¾—ã‚’å„ªå…ˆï¼‰"""
        try:
            # ã¾ãšS&P500ãƒ‡ãƒ¼ã‚¿å†…ã®VIXåˆ—ã‚’ãƒã‚§ãƒƒã‚¯
            if not self.sp500_df.empty and 'VIX' in self.sp500_df.columns:
                vix_series = self.sp500_df['VIX'].dropna()
                if not vix_series.empty: # Check if series is not empty after dropna
                    vix_value = float(vix_series.iloc[-1])
                    self.logger.info(f"VIXå€¤å–å¾—æˆåŠŸ: {vix_value} (S&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰)")
                    return vix_value
            
            # æ¬¡ã«å¸‚å ´ãƒ‡ãƒ¼ã‚¿è¾æ›¸ã‹ã‚‰å–å¾—
            self.logger.info("=== VIXå€¤å–å¾—é–‹å§‹ ===")
            self.logger.info(f"åˆ©ç”¨å¯èƒ½ãªã‚­ãƒ¼: {list(self.market_data_dict.keys())}")
            
            for key in ["VIX", "^VIX", "vix", "volatility"]:
                if key in self.market_data_dict:
                    vix_data = self.market_data_dict[key]
                    self.logger.info(f"VIXã‚­ãƒ¼ '{key}' ç™ºè¦‹: {type(vix_data)}")
                    
                    if isinstance(vix_data, dict):
                        if "df" in vix_data and isinstance(vix_data["df"], pd.DataFrame) and not vix_data["df"].empty:
                            vix_df = vix_data["df"]
                            if "Close" in vix_df.columns and not vix_df["Close"].dropna().empty:
                                vix_value = float(vix_df["Close"].dropna().iloc[-1])
                                self.logger.info(f"VIXå€¤å–å¾—æˆåŠŸ: {vix_value} (from df)")
                                return vix_value
                        elif "Close" in vix_data: # Assuming this is a direct value or list
                            close_data = vix_data["Close"]
                            if isinstance(close_data, list) and len(close_data) > 0:
                                vix_value = float(close_data[-1])
                                self.logger.info(f"VIXå€¤å–å¾—æˆåŠŸ: {vix_value} (from list)")
                                return vix_value
                            elif isinstance(close_data, (int, float)):
                                vix_value = float(close_data)
                                self.logger.info(f"VIXå€¤å–å¾—æˆåŠŸ: {vix_value} (from direct value in dict)")
                                return vix_value
                    elif isinstance(vix_data, (int, float)):
                        self.logger.info(f"VIXå€¤å–å¾—æˆåŠŸ: {vix_data} (direct)")
                        return float(vix_data)
                    elif isinstance(vix_data, pd.Series) and not vix_data.dropna().empty:
                        vix_value = float(vix_data.dropna().iloc[-1])
                        self.logger.info(f"VIXå€¤å–å¾—æˆåŠŸ: {vix_value} (from Series)")
                        return vix_value
            
            # S&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’è¨ˆç®—
            if not self.sp500_df.empty and 'Close' in self.sp500_df.columns and len(self.sp500_df['Close']) >= 20 :
                returns = self.sp500_df['Close'].pct_change().dropna().tail(20)
                if not returns.empty:
                    volatility = returns.std() * np.sqrt(252) * 100
                    estimated_vix = min(80.0, max(10.0, volatility)) # Ensure float
                    self.logger.info(f"VIXæ¨å®šå€¤: {estimated_vix:.1f} (ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã‹ã‚‰è¨ˆç®—)")
                    return estimated_vix
            
            self.logger.warning("VIXå€¤ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤20.0ã‚’ä½¿ç”¨")
            return 20.0
            
        except Exception as e:
            self.logger.error(f"VIXå–å¾—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True) # Log traceback
            return 20.0

    def _calculate_technical_indicators(self) -> Dict[str, Any]:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—ï¼ˆS&P500ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç›´æ¥å–å¾—ã‚’å„ªå…ˆï¼‰"""
        if self.sp500_df.empty:
            return {}
        
        try:
            tech_data = {}
            df_copy = self.sp500_df.copy() # Operate on a copy to avoid SettingWithCopyWarning
            
            # RSI
            if 'RSI' in df_copy.columns and not df_copy['RSI'].dropna().empty:
                current_rsi = df_copy['RSI'].dropna().iloc[-1]
                if pd.notna(current_rsi):
                    tech_data["rsi_current"] = float(current_rsi)
                    if current_rsi >= 70: tech_data["rsi_signal"] = "éè²·ã„"
                    elif current_rsi <= 30: tech_data["rsi_signal"] = "éå£²ã‚Š"
                    else: tech_data["rsi_signal"] = "ä¸­ç«‹"
            elif 'Close' in df_copy.columns and len(df_copy['Close']) >= 15: # Need 14 periods for RSI + 1 for diff
                delta = df_copy['Close'].diff()
                gain = (delta.where(delta > 0, 0.0)).rolling(window=14, min_periods=1).mean()
                loss = (-delta.where(delta < 0, 0.0)).rolling(window=14, min_periods=1).mean()
                
                # Avoid division by zero for RS
                rs = gain / loss.replace(0, np.nan) # Replace 0 loss with NaN to avoid inf/nan issues in RS
                rs = rs.fillna(method='ffill').fillna(0) # Fill NaNs in RS, e.g., if loss was 0 for a period
                
                rsi = 100 - (100 / (1 + rs))
                if not rsi.dropna().empty:
                    current_rsi = rsi.dropna().iloc[-1]
                    if pd.notna(current_rsi):
                        tech_data["rsi_current"] = float(current_rsi)
                        if current_rsi >= 70: tech_data["rsi_signal"] = "éè²·ã„"
                        elif current_rsi <= 30: tech_data["rsi_signal"] = "éå£²ã‚Š"
                        else: tech_data["rsi_signal"] = "ä¸­ç«‹"
            
            # ç§»å‹•å¹³å‡ç·š
            if 'Close' in df_copy.columns and not df_copy['Close'].empty:
                current_price = df_copy['Close'].iloc[-1]
                ma_signals = {}
                ma_periods_to_check = {'MA5': 5, 'MA20': 20, 'MA50': 50, 'MA60': 60, 'MA120': 120}

                for ma_col, period in ma_periods_to_check.items():
                    if ma_col in df_copy.columns and not df_copy[ma_col].dropna().empty:
                        ma_value = df_copy[ma_col].dropna().iloc[-1]
                        if pd.notna(ma_value):
                            ma_signals[f"price_vs_{ma_col.lower()}"] = "above" if current_price > ma_value else "below"
                    elif len(df_copy['Close']) >= period:
                        # Calculate MA if not present and data is sufficient
                        df_copy[ma_col] = df_copy['Close'].rolling(window=period).mean()
                        if not df_copy[ma_col].dropna().empty:
                            ma_value = df_copy[ma_col].dropna().iloc[-1]
                            if pd.notna(ma_value):
                                ma_signals[f"price_vs_{ma_col.lower()}"] = "above" if current_price > ma_value else "below"
                
                # MAåŒå£«ã®æ¯”è¼ƒ (MA5 vs MA20)
                ma5_val, ma20_val = None, None
                if 'MA5' in df_copy.columns and not df_copy['MA5'].dropna().empty: ma5_val = df_copy['MA5'].dropna().iloc[-1]
                if 'MA20' in df_copy.columns and not df_copy['MA20'].dropna().empty: ma20_val = df_copy['MA20'].dropna().iloc[-1]

                if pd.notna(ma5_val) and pd.notna(ma20_val):
                    ma_signals["ma5_vs_ma20"] = "above" if ma5_val > ma20_val else "below"
                
                if ma_signals: tech_data["ma_signals"] = ma_signals

            # ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¯ãƒ­ã‚¹ãƒ»ãƒ‡ãƒƒãƒ‰ã‚¯ãƒ­ã‚¹
            if 'golden_cross' in df_copy.columns and 'death_cross' in df_copy.columns:
                recent_data = df_copy.tail(30)
                golden_cross_recent = recent_data['golden_cross'].any() if not recent_data['golden_cross'].empty else False
                death_cross_recent = recent_data['death_cross'].any() if not recent_data['death_cross'].empty else False
                
                if golden_cross_recent: tech_data["recent_cross"] = "golden"
                elif death_cross_recent: tech_data["recent_cross"] = "death"
                else: tech_data["recent_cross"] = "none"
            
            self.logger.info(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—å®Œäº†: {tech_data}")
            return tech_data
            
        except Exception as e:
            self.logger.error(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {}

    def _get_technical_signals_summary(self) -> Dict[str, Any]:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚·ã‚°ãƒŠãƒ«ã®ã‚µãƒãƒªãƒ¼ï¼ˆæ”¹è‰¯ç‰ˆï¼‰"""
        try:
            summary = {
                "ma_cross_status": "MAã‚¯ãƒ­ã‚¹ã¯30æ—¥ä»¥å†…ã«ãªã—",
                "total_buy_score": 0,
                "total_sell_score": 0,
                "recent_days_for_count": 15, # This seems unused in current logic but kept for now
                "rsi_signal": "ä¸­ç«‹"
            }
            
            tech_indicators = self._calculate_technical_indicators()
            summary.update(tech_indicators) # Update with calculated indicators
            
            buy_score = 0
            sell_score = 0
            
            if "rsi_signal" in tech_indicators:
                rsi_s = tech_indicators["rsi_signal"]
                if rsi_s == "éå£²ã‚Š": buy_score += 3
                elif rsi_s == "éè²·ã„": sell_score += 3
                else: # Neutral RSI
                    rsi_val = tech_indicators.get("rsi_current", 50)
                    if rsi_val < 40: buy_score += 1
                    elif rsi_val > 60: sell_score += 1
            
            if "ma_signals" in tech_indicators:
                ma_s = tech_indicators["ma_signals"]
                above_count = sum(1 for k, v in ma_s.items() if k.startswith("price_vs_") and v == "above")
                below_count = sum(1 for k, v in ma_s.items() if k.startswith("price_vs_") and v == "below")
                
                if above_count > below_count: buy_score += above_count
                elif below_count > above_count : sell_score += below_count # Only score if one clearly dominates
                # else: neutral, no score change

                if ma_s.get("ma5_vs_ma20") == "above": buy_score += 1
                elif ma_s.get("ma5_vs_ma20") == "below": sell_score += 1 # Check for 'below' as well
            
            if "recent_cross" in tech_indicators:
                cross = tech_indicators["recent_cross"]
                if cross == "golden":
                    buy_score += 2
                    summary["ma_cross_status"] = "ç›´è¿‘ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¯ãƒ­ã‚¹ç™ºç”Ÿ"
                elif cross == "death":
                    sell_score += 2
                    summary["ma_cross_status"] = "ç›´è¿‘ãƒ‡ãƒƒãƒ‰ã‚¯ãƒ­ã‚¹ç™ºç”Ÿ"
            
            summary["total_buy_score"] = buy_score
            summary["total_sell_score"] = sell_score
            
            self.logger.info(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚µãƒãƒªãƒ¼: è²·ã„={buy_score}, å£²ã‚Š={sell_score}, RSI={summary.get('rsi_signal','N/A')}, MAã‚¯ãƒ­ã‚¹={summary.get('ma_cross_status','N/A')}")
            return summary
            
        except Exception as e:
            self.logger.error(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {"error": str(e)}

    def _generate_comprehensive_market_assessment(self, market_status: Dict, predictions: Dict, 
                                                  errors: Dict, tech_signals: Dict) -> MarketAssessment:
        """ç·åˆå¸‚å ´è©•ä¾¡ã‚’ç”Ÿæˆï¼ˆAIäºˆæ¸¬é‡è¦–ï¼‹æ¥µç«¯å€¤æŠ‘åˆ¶ãƒ»é‡ã¿èª¿æ•´ç‰ˆï¼‰"""
        try:
            # --- AIäºˆæ¸¬ã®ä¿¡é ¼åº¦è£œæ­£ï¼ˆæ¥µç«¯ãªå€¤ã‚’æŠ‘åˆ¶ï¼‰ ---
            corrected_predictions = {} # Store corrected predictions to avoid modifying input dict directly
            for period in ['nextday_price', 'short_term', 'long_term']:
                pred_key = 'change_pct' if period == 'nextday_price' else 'trend_pct'
                original_pred_data = predictions.get(period, {})
                corrected_pred_data = original_pred_data.copy() # Work on a copy

                trend_pct_val = corrected_pred_data.get(pred_key, 0)
                confidence = corrected_pred_data.get('confidence', 0.5)
                
                if abs(trend_pct_val) > 20:
                    corrected_pred_data['confidence'] = confidence * 0.5
                elif abs(trend_pct_val) > 10:
                    corrected_pred_data['confidence'] = confidence * 0.8
                corrected_predictions[period] = corrected_pred_data


            # --- ç·åˆãƒˆãƒ¬ãƒ³ãƒ‰ã‚’åŠ é‡å¹³å‡ã§ç®—å‡º ---
            weights = {'nextday_price': 0.4, 'short_term': 0.4, 'long_term': 0.2}
            weighted_trend = 0
            total_confidence_weight = 0 # Sum of (weight * confidence)
            total_base_weight = 0 # Sum of base weights for normalization

            for period, pred_data in corrected_predictions.items():
                if period not in weights: continue # Skip if no weight defined
                pred_key = 'change_pct' if period == 'nextday_price' else 'trend_pct'
                trend = pred_data.get(pred_key, 0)
                conf = pred_data.get('confidence', 0)
                
                current_weight_factor = weights[period]
                weighted_trend += trend * conf * current_weight_factor # Trend weighted by confidence and period_weight
                total_confidence_weight += conf * current_weight_factor
                total_base_weight += current_weight_factor


            final_trend = (weighted_trend / total_confidence_weight) if total_confidence_weight > 0 else 0
            # Normalize confidence by dividing sum of (conf*weight) by sum of (weights)
            final_confidence = (total_confidence_weight / total_base_weight) if total_base_weight > 0 else 0.5


            # --- ãƒˆãƒ¬ãƒ³ãƒ‰åˆ¤å®š ---
            if final_trend < -3: trend_label = "bearish"
            elif final_trend > 3: trend_label = "bullish"
            else: trend_label = "neutral"

            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æã‚¹ã‚³ã‚¢
            buy_score = tech_signals.get("total_buy_score", 0)
            sell_score = tech_signals.get("total_sell_score", 0)

            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã¨AIäºˆæ¸¬ã®çµ±åˆï¼ˆé‡ã¿ä»˜ã‘æ”¹å–„ï¼‰
            final_trend, final_confidence = self._resolve_prediction_conflicts(
    trend, final_trend, buy_score, sell_score, final_confidence
)
trend = final_trend

                # AIäºˆæ¸¬ãŒå¤§å¹…ä¸‹è½ã®å ´åˆã¯ã‚ˆã‚Šæ…é‡ã«
                if final_trend < -5: # If underlying AI trend was actually bearish despite label
                    trend_label = "bearish"
                    final_confidence *= 0.6
                else:
                    trend_label = "neutral"
                    final_confidence *= 0.8
            elif trend_label == "bearish" and buy_score > sell_score + 2: # Tech strongly disagrees
                if final_trend > 5: # If underlying AI trend was actually bullish
                    trend_label = "bullish"
                    final_confidence *= 0.6
                else:
                    trend_label = "neutral"
                    final_confidence *= 0.8
            elif trend_label == "neutral": # AI is neutral, let tech guide
                if buy_score > sell_score + 1:
                    trend_label = "bullish"
                    final_confidence = max(final_confidence, 0.55) # Boost confidence slightly
                elif sell_score > buy_score + 1:
                    trend_label = "bearish"
                    final_confidence = max(final_confidence, 0.55)

            # ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«
            vix_value = market_status.get("VIX", 20.0) # Ensure float
            volatility_5d = market_status.get("volatility_5d", 0.0) # Ensure float
            risk_factors = 0
            if vix_value > 30: risk_factors += 3
            elif vix_value > 25: risk_factors += 2
            elif vix_value > 20: risk_factors += 1
            
            if volatility_5d > 25: risk_factors += 2
            elif volatility_5d > 15: risk_factors += 1
            
            if final_confidence < 0.4: risk_factors += 1
            
            # If trend is very strong but confidence is low, that's also a risk
            if abs(final_trend) > 7 and final_confidence < 0.5: risk_factors +=1


            if risk_factors >= 5: risk_level = "high"
            elif risk_factors >= 2: risk_level = "medium"
            else: risk_level = "low"

            # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢ (0 to 1, 0.5 is neutral)
            tech_score = 0.5
            total_tech_signals = buy_score + sell_score
            if total_tech_signals > 0:
                tech_score = buy_score / total_tech_signals
            tech_score = max(0.0, min(1.0, tech_score))

            ai_reliability_score = max(0.1, min(0.9, final_confidence)) # Ensure within bounds

            result = MarketAssessment(
                trend=trend_label,
                confidence=ai_reliability_score, # Use the final AI confidence
                risk_level=risk_level,
                tech_score=tech_score,
                ai_reliability=ai_reliability_score 
            )
            self.logger.info(f"ç·åˆè©•ä¾¡: {result.trend}, ä¿¡é ¼åº¦={result.confidence:.2f}, ãƒªã‚¹ã‚¯={result.risk_level}, AIãƒˆãƒ¬ãƒ³ãƒ‰å€¤={final_trend:.2f}")
            return result

        except Exception as e:
            self.logger.error(f"ç·åˆå¸‚å ´è©•ä¾¡ã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}", exc_info=True)
            return MarketAssessment(
                trend="neutral", confidence=0.5, risk_level="medium",
                tech_score=0.5, ai_reliability=0.5
            )

    def _get_current_config(self) -> Dict[str, Any]:
        return self.builtin_config.get(self.current_profile, self.builtin_config["natural"])

    def _get_current_profile_name(self) -> str:
        return self.current_profile

    def _get_current_market_status(self) -> Dict[str, Any]:
        if self.sp500_df is None or self.sp500_df.empty or 'Close' not in self.sp500_df.columns:
            self.logger.error("S&P500ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã¾ãŸã¯'Close'åˆ—ãªã—ã€‚å¸‚å ´çŠ¶æ³å–å¾—ä¸å¯ã€‚")
            return {"error": "ãƒ‡ãƒ¼ã‚¿ä¸è¶³"}
        
        try:
            latest_row = self.sp500_df.iloc[-1]
            current_price = float(latest_row["Close"])
            
            daily_change = 0.0
            if len(self.sp500_df) > 1 and 'Close' in self.sp500_df.columns:
                prev_price = float(self.sp500_df["Close"].iloc[-2])
                if prev_price != 0: # Avoid division by zero
                    daily_change = ((current_price - prev_price) / prev_price) * 100
            
            vix_value = self._get_vix_value() # Already ensures float
            
            volatility_5d = 0.0
            if len(self.sp500_df) >= 6 and 'Close' in self.sp500_df.columns: # Need 6 rows for 5 pct_change values
                returns = self.sp500_df["Close"].pct_change().dropna().tail(5)
                if len(returns) == 5: # Ensure we have 5 returns
                    volatility_5d = float(returns.std() * np.sqrt(252) * 100)
            
            status = {
                "current_price": round(current_price, 2),
                "last_price_date": self.sp500_df.index[-1].strftime("%Y-%m-%d") if isinstance(self.sp500_df.index[-1], pd.Timestamp) else str(self.sp500_df.index[-1]),
                "volume": float(latest_row.get("Volume", 0.0)),
                "daily_change": round(daily_change, 2),
                "volatility_5d": round(volatility_5d, 2),
                "VIX": round(vix_value, 2),
                "vix_level": self._categorize_vix(vix_value)
            }
            
            self.logger.info(f"å¸‚å ´çŠ¶æ³: ä¾¡æ ¼=${status['current_price']:.2f}, å¤‰å‹•={status['daily_change']:.2f}%, VIX={status['VIX']:.1f}")
            return status
            
        except Exception as e:
            self.logger.error(f"å¸‚å ´çŠ¶æ³å–å¾—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {"error": str(e)}

    def _categorize_vix(self, vix_value: float) -> str:
        if vix_value < 15: return "ä½ä½å®‰å®š"
        elif vix_value < 25: return "é€šå¸¸ç¯„å›²"
        elif vix_value < 35: return "è­¦æˆ’ãƒ¬ãƒ™ãƒ«"
        else: return "ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«"

    def _generate_investment_advice_from_assessment(self, assessment: MarketAssessment) -> Dict[str, Any]:
        try:
            config = self._get_current_config()
            confidence_threshold = config.get("confidence_threshold", 0.6)
            
            predictions, _ = self._get_ai_predictions_summary()
            # Use the most relevant AI trend, e.g., long_term or a weighted average
            # For simplicity, using long_term here, but could be more sophisticated
            ai_long_term_pred = predictions.get("long_term", {})
            ai_trend_pct = ai_long_term_pred.get("trend_pct", 0.0)
            ai_trend_confidence = ai_long_term_pred.get("confidence", 0.5)

            primary_action = "HOLD"
            action_strength = "ä¸­"
            reason = "ç·åˆè©•ä¾¡ã«åŸºã¥ãåˆ¤æ–­ä¸­"

            # Decision logic considering assessment trend, confidence, risk, and direct AI trend
            if assessment.confidence < confidence_threshold:
                primary_action = "HOLD"
                action_strength = "å¼±"
                reason = f"ç·åˆä¿¡é ¼åº¦({assessment.confidence:.1%})ãŒé–¾å€¤({confidence_threshold:.1%})æœªæº€"
            
            elif assessment.trend == "bullish":
                if assessment.risk_level == "high":
                    primary_action = "HOLD" # High risk overrides bullish trend
                    action_strength = "ä¸­"
                    reason = "ä¸Šæ˜‡ãƒˆãƒ¬ãƒ³ãƒ‰ã ãŒé«˜ãƒªã‚¹ã‚¯ç’°å¢ƒ"
                elif ai_trend_pct < -1.0 and ai_trend_confidence > 0.6: # AI strongly predicts decline despite bullish assessment
                    primary_action = "HOLD"
                    action_strength = "å¼±"
                    reason = f"ç·åˆè©•ä¾¡ã¯ä¸Šæ˜‡ã ãŒã€AIãŒä¸‹è½ã‚’ç¤ºå”†(AI Trend: {ai_trend_pct:.1f}%)"
                else:
                    primary_action = "BUY"
                    action_strength = "å¼·" if assessment.confidence > 0.75 and ai_trend_pct > 2.0 else "ä¸­"
                    reason = f"ä¸Šæ˜‡ãƒˆãƒ¬ãƒ³ãƒ‰ç¢ºèª (ç·åˆãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.trend}, AI Trend: {ai_trend_pct:.1f}%)"
            
            elif assessment.trend == "bearish":
                if assessment.risk_level == "high" and ai_trend_pct < -3.0 : # High risk and strong AI bearish
                     primary_action = "SELL"
                     action_strength = "å¼·"
                     reason = f"ä¸‹é™ãƒˆãƒ¬ãƒ³ãƒ‰ã‹ã¤é«˜ãƒªã‚¹ã‚¯ (ç·åˆãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.trend}, AI Trend: {ai_trend_pct:.1f}%)"
                elif ai_trend_pct > 1.0 and ai_trend_confidence > 0.6: # AI strongly predicts rise despite bearish assessment
                    primary_action = "HOLD"
                    action_strength = "å¼±"
                    reason = f"ç·åˆè©•ä¾¡ã¯ä¸‹é™ã ãŒã€AIãŒä¸Šæ˜‡ã‚’ç¤ºå”†(AI Trend: {ai_trend_pct:.1f}%)"
                else:
                    primary_action = "SELL"
                    action_strength = "ä¸­" # Default to medium for sell unless very strong signals
                    if assessment.confidence > 0.75 and ai_trend_pct < -2.0: action_strength = "å¼·"
                    reason = f"ä¸‹é™ãƒˆãƒ¬ãƒ³ãƒ‰ç¢ºèª (ç·åˆãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.trend}, AI Trend: {ai_trend_pct:.1f}%)"

            else: # Neutral assessment trend
                primary_action = "HOLD"
                if ai_trend_pct > 2.0 and ai_trend_confidence > 0.65 and assessment.risk_level != "high":
                    primary_action = "BUY"
                    action_strength = "å¼±"
                    reason = f"ç·åˆä¸­ç«‹ã ãŒAIãŒã‚„ã‚„å¼·ã„ä¸Šæ˜‡ã‚’ç¤ºå”† (AI Trend: {ai_trend_pct:.1f}%)"
                elif ai_trend_pct < -2.0 and ai_trend_confidence > 0.65 :
                    primary_action = "SELL"
                    action_strength = "å¼±"
                    reason = f"ç·åˆä¸­ç«‹ã ãŒAIãŒã‚„ã‚„å¼·ã„ä¸‹è½ã‚’ç¤ºå”† (AI Trend: {ai_trend_pct:.1f}%)"
                else:
                    action_strength = "ä¸­"
                    reason = "æ˜ç¢ºãªãƒˆãƒ¬ãƒ³ãƒ‰ãªã—ã€ã¾ãŸã¯AIã‚·ã‚°ãƒŠãƒ«ãŒå¼±ã„"

            # Warnings
            warnings = []
            if ai_trend_pct < -5: warnings.append(f"ğŸš¨ AIãŒå¤§å¹…ä¸‹è½ã‚’è­¦å‘Š: {ai_trend_pct:.1f}%")
            elif ai_trend_pct < -2: warnings.append(f"âš ï¸ AIãŒä¸‹è½ã‚’ç¤ºå”†: {ai_trend_pct:.1f}%")
            if ai_trend_pct > 5: warnings.append(f"ğŸ“ˆ AIãŒå¤§å¹…ä¸Šæ˜‡ã‚’ç¤ºå”†: +{ai_trend_pct:.1f}%")
            
            if assessment.risk_level == "high": warnings.append("âš ï¸ é«˜ãƒªã‚¹ã‚¯å¸‚å ´ç’°å¢ƒ")
            if assessment.confidence < 0.4: warnings.append("âš ï¸ ç·åˆäºˆæ¸¬ä¿¡é ¼åº¦ãŒä½ã„")
            if assessment.ai_reliability < 0.4: warnings.append("âš ï¸ AIè‡ªä½“ã®ä¿¡é ¼æ€§ãŒä½ã„å¯èƒ½æ€§")
            
            warnings.extend([
                "æŠ•è³‡ã¯å…ƒæœ¬ä¿è¨¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä½™è£•è³‡é‡‘ã§ã®æŠ•è³‡ã‚’å¿ƒãŒã‘ã¦ãã ã•ã„ã€‚",
                "ã“ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã¯æƒ…å ±æä¾›ç›®çš„ã§ã‚ã‚Šã€æŠ•è³‡ã®æœ€çµ‚åˆ¤æ–­ã¯ã”è‡ªèº«ã§è¡Œã£ã¦ãã ã•ã„ã€‚"
            ])
            
            return {
                "primary_action": primary_action,
                "action_strength": action_strength,
                "risk_assessment": f"{assessment.risk_level.upper()}ãƒªã‚¹ã‚¯",
                "confidence_score": float(assessment.confidence), # Ensure float
                "profile_adjusted_advice": {
                    "advice_text": f"ã€{self.current_profile.upper()}ã€‘{primary_action}æ¨å¥¨ï¼ˆ{action_strength}ï¼‰- {reason}",
                    "position_sizing": self._get_position_sizing_advice(primary_action, assessment.risk_level)
                },
                "key_factors": [
                    f"AIé•·æœŸäºˆæ¸¬: {ai_trend_pct:+.1f}% (ä¿¡é ¼åº¦: {ai_trend_confidence:.1%})",
                    f"ç·åˆå¸‚å ´ãƒˆãƒ¬ãƒ³ãƒ‰è©•ä¾¡: {assessment.trend.upper()}",
                    f"ç·åˆä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢: {assessment.confidence:.1%}",
                    f"å¸‚å ´ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«: {assessment.risk_level.upper()}",
                    f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚³ã‚¢: {assessment.tech_score:.2f}"
                ],
                "recommendations": self._get_basic_recommendations(primary_action),
                "warnings": warnings[:5] # Limit warnings
            }
            
        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {
                "error": str(e), "primary_action": "HOLD", "action_strength": "å¼±",
                "risk_assessment": "ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã«ã‚ˆã‚Šé«˜ãƒªã‚¹ã‚¯"
            }

    def _get_position_sizing_advice(self, action: str, risk_level: str) -> str:
        if action == "HOLD":
            return "ç¾çŠ¶ç¶­æŒ"
        
        profile_multipliers = {"conservative": 0.5, "natural": 1.0, "aggressive": 1.5}
        risk_multipliers = {"low": 1.2, "medium": 0.8, "high": 0.4} # Adjusted risk multipliers
        
        base_size_pct = 5 # Base size as percentage of portfolio for this asset
        profile_mult = profile_multipliers.get(self.current_profile, 1.0)
        risk_mult = risk_multipliers.get(risk_level.lower(), 0.8) # ensure lower case for key
        
        recommended_size_pct = base_size_pct * profile_mult * risk_mult
        recommended_size_pct = round(max(1.0, min(20.0, recommended_size_pct)),1) # Cap between 1% and 20%
        
        return f"ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã®{recommended_size_pct}%ç¨‹åº¦"

    def _get_basic_recommendations(self, action: str) -> List[str]:
        recommendations = {
            "BUY": [
                "ETFã‚„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ•ã‚¡ãƒ³ãƒ‰ã§ã®S&P500ã¸ã®æŠ•è³‡ã‚’æ¤œè¨ã€‚",
                "ãƒ‰ãƒ«ã‚³ã‚¹ãƒˆå¹³å‡æ³•ã«ã‚ˆã‚‹æ®µéšçš„ãªæŠ•è³‡å®Ÿè¡Œã‚‚ä¸€è€ƒã€‚",
                "æŠ•è³‡å‰ã«è‡ªèº«ã®ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªå…¨ä½“ã®ãƒªã‚¹ã‚¯è¨±å®¹åº¦ã‚’å†ç¢ºèªã€‚"
            ],
            "SELL": [
                "å¸‚å ´ãŒä¸å®‰å®šãªå ´åˆã¯æ®µéšçš„ãªåˆ©ç¢ºã¾ãŸã¯æåˆ‡ã‚Šã‚’æ¤œè¨ã€‚",
                "ç¾é‡‘ãƒã‚¸ã‚·ãƒ§ãƒ³ã®å¢—åŠ ã§ãƒªã‚¹ã‚¯ãƒ˜ãƒƒã‚¸ã‚‚è€ƒæ…®ã€‚",
                "ç¨å‹™ä¸Šã®å½±éŸ¿ã‚‚è€ƒæ…®ã—ã¦å£²å´ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨ˆç”»ã€‚"
            ],
            "HOLD": [
                "ç¾åœ¨ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ç¶­æŒã—ã€å¸‚å ´å‹•å‘ã‚’æ³¨è¦–ã€‚",
                "æ€¥ãªå¸‚å ´å¤‰å‹•ã«å‚™ãˆã€è¿½åŠ æŠ•è³‡ã‚„ä¸€éƒ¨å£²å´ã®ã‚·ãƒŠãƒªã‚ªã‚’æº–å‚™ã€‚",
                "é–¢é€£ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚„çµŒæ¸ˆæŒ‡æ¨™ã®ãƒã‚§ãƒƒã‚¯ã‚’ç¶™ç¶šã€‚"
            ]
        }
        return recommendations.get(action, recommendations["HOLD"])


    def generate_investment_advice(self) -> Dict[str, Any]:
        try:
            self.logger.info(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹ (ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_profile})")
            
            market_status = self._get_current_market_status()
            if "error" in market_status: 
                self.logger.error(f"å¸‚å ´çŠ¶æ³å–å¾—ã‚¨ãƒ©ãƒ¼: {market_status['error']}")
                return {"error": f"å¸‚å ´çŠ¶æ³å–å¾—ã‚¨ãƒ©ãƒ¼: {market_status['error']}"}

            predictions, errors = self._get_ai_predictions_summary()
            if not predictions : # Check if predictions dict is empty
                self.logger.error("AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼ãŒç©ºã§ã™ã€‚ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆä¸å¯ã€‚")
                return {"error": "AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼ãŒç©º"}
                
            tech_signals = self._get_technical_signals_summary()
            if "error" in tech_signals:
                self.logger.warning(f"ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™å–å¾—ã‚¨ãƒ©ãƒ¼: {tech_signals['error']}. é™å®šæƒ…å ±ã§è©•ä¾¡ç¶™ç¶šã€‚")
                # Provide default or empty tech_signals to proceed if acceptable
                # tech_signals = {"total_buy_score":0, "total_sell_score":0} 

            assessment = self._generate_comprehensive_market_assessment(
                market_status, predictions, errors, tech_signals
            )
            
            advice = self._generate_investment_advice_from_assessment(assessment)
            
            # Ensure all components are serializable for JSON
            # Numpy types need conversion, pandas timestamps too.
            def make_serializable(data):
                if isinstance(data, dict):
                    return {k: make_serializable(v) for k, v in data.items()}
                elif isinstance(data, list):
                    return [make_serializable(i) for i in data]
                elif isinstance(data, (np.floating, np.integer)):
                    return float(data) if isinstance(data, np.floating) else int(data)
                elif isinstance(data, np.ndarray):
                    return data.tolist()
                elif isinstance(data, pd.Timestamp):
                    return data.isoformat()
                # Add other types if necessary
                return data

            return make_serializable({
                "metadata": {
                    "generated_at": datetime.now().isoformat(),
                    "profile": self.current_profile,
                    "calculation_errors": self.calculation_errors # Ensure this is serializable
                },
                "market_analysis": {
                    "current_status": market_status,
                    "ai_predictions": predictions,
                    "ai_model_errors": errors, # Renamed from ai_reliability for clarity
                    "technical_signals": tech_signals
                },
                "assessment": {
                    "overall_trend": assessment.trend,
                    "confidence_score": assessment.confidence,
                    "risk_level": assessment.risk_level,
                    "technical_score": assessment.tech_score,
                    "ai_reliability": assessment.ai_reliability 
                },
                "investment_advice": advice
            })
            
        except Exception as e:
            self.logger.error(f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã®æœ€ä¸Šä½ã§ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {"error": f"æŠ•è³‡ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"}

    def generate_investment_report(self, save_to_json: bool = False, print_to_console: bool = True) -> bool:
        try:
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™")
            report_data = self.generate_investment_advice()
            
            if "error" in report_data:
                self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {report_data['error']}")
                if print_to_console: print(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {report_data['error']}")
                return False
            
            self._log_prediction_summary() # Log summary of extracted prices
            
            if print_to_console:
                # Add timestamp for display if not already there (generate_investment_advice adds it to metadata)
                report_data_display = report_data.copy()
                report_data_display['timestamp'] = report_data_display.get("metadata",{}).get("generated_at", datetime.now().isoformat())
                self._display_enhanced_report(report_data_display)
            
            if save_to_json:
                # Add extracted prediction prices to the report before saving if needed
                # report_data_save = report_data.copy() # Already serializable from generate_investment_advice
                # report_data_save['prediction_prices_extracted'] = self._extract_prediction_prices()
                self._save_report_to_json(report_data) # report_data should be serializable now
            
            self.logger.info("æŠ•è³‡ãƒ¬ãƒãƒ¼ãƒˆç”ŸæˆãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
            return True
        except Exception as e:
            self.logger.error(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            if print_to_console: print(f"ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _print_report(self, data: Dict[str, Any]): 
        # This method seems redundant if _display_enhanced_report is used.
        # Kept for reference or if a different format is needed.
        # Ensure it handles the structure of `data` from `generate_investment_advice`.
        print("\n" + "="*60)
        print("        ğŸ¯ AIæŠ•è³‡åˆ†æãƒ¬ãƒãƒ¼ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°ç‰ˆï¼‰ ğŸ¯") # Changed title for distinction
        print("="*60)
        
        metadata = data.get("metadata", {})
        print(f"ğŸ“… ç”Ÿæˆæ—¥æ™‚: {metadata.get('generated_at', 'N/A')}")
        print(f"ğŸ‘¤ æŠ•è³‡ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«: {metadata.get('profile', 'N/A').upper()}")
        
        assessment = data.get("assessment", {})
        advice = data.get("investment_advice", {})
        market = data.get("market_analysis", {}).get("current_status", {})
        ai_predictions_summary = data.get("market_analysis", {}).get("ai_predictions", {}) # Actual summary
        
        # Displaying a specific AI prediction for simplicity (e.g., long_term)
        long_term_pred = ai_predictions_summary.get("long_term", {})
        ai_trend_display = long_term_pred.get("trend_pct", 0)
        ai_confidence_display = long_term_pred.get("confidence", 0)

        print(f"\nğŸ¤– ã€AIäºˆæ¸¬æ¦‚è¦ã€‘")
        print(f"é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬ (AI): {ai_trend_display:+.2f}%")
        print(f"ãã®ä¿¡é ¼åº¦ (AI): {ai_confidence_display:.1%}")
        
        print(f"\nğŸ“Š ã€ç·åˆè©•ä¾¡ã€‘")
        print(f"è©•ä¾¡ãƒˆãƒ¬ãƒ³ãƒ‰: {assessment.get('overall_trend', 'N/A').upper()}")
        print(f"è©•ä¾¡ä¿¡é ¼åº¦: {assessment.get('confidence_score', 0.0):.1%}") # Ensure float
        print(f"ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«: {assessment.get('risk_level', 'N/A').upper()}")
        
        print(f"\nğŸ’¡ ã€æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€‘")
        print(f"ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {advice.get('primary_action', 'N/A')}")
        print(f"å¼·åº¦: {advice.get('action_strength', 'N/A')}")
        
        if market and "error" not in market:
            print(f"\nğŸ“ˆ ã€å¸‚å ´çŠ¶æ³ã€‘")
            print(f"S&P500ä¾¡æ ¼: ${market.get('current_price', 0.0):.2f}")
            print(f"VIXæŒ‡æ•°: {market.get('VIX', 0.0):.1f}")
        
        print("="*60)


    def _save_report_to_json(self, report_data: Dict[str, Any]) -> bool:
        try:
            # Filename generation
            profile_name = self.current_profile or "unknown_profile"
            timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"investment_report_{profile_name}_{timestamp_str}.json"
            
            # The report_data from generate_investment_advice should already be serializable
            # If _save_analysis_report performs cleaning, it's fine.
            saved_path = self._save_analysis_report(report_data, filename)
            return bool(saved_path)
        except Exception as e:
            self.logger.error(f"JSONä¿å­˜ã®å‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return False

    def _save_analysis_report(self, report_data: Dict[str, Any], filename: str) -> Optional[str]:
        # The clean_data function from the previous context is assumed here.
        # If report_data is already cleaned by generate_investment_advice's make_serializable,
        # this clean_data might be redundant but harmless.
        def clean_data_for_json(obj): # Renamed to avoid conflict if defined globally
            if isinstance(obj, dict):
                return {k: clean_data_for_json(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [clean_data_for_json(v) for v in obj]
            elif pd.isna(obj): return None
            elif isinstance(obj, (np.integer, np.floating, np.bool_)): # Added np.bool_
                return (float(obj) if isinstance(obj, np.floating) 
                        else int(obj) if isinstance(obj, np.integer) 
                        else bool(obj))
            elif isinstance(obj, pd.Timestamp): return obj.isoformat()
            # Standard Python types that are JSON serializable
            elif isinstance(obj, (str, int, float, bool, type(None))):
                return obj
            # Fallback for other types: convert to string
            else:
                # self.logger.warning(f"Unserializable type {type(obj)} found, converting to string.")
                return str(obj)
        
        try:
            # It's better if generate_investment_advice ensures serializability.
            # If not, clean_data_for_json is a fallback.
            # cleaned_report_data = clean_data_for_json(report_data) 
            
            # Assuming report_data is already serializable by generate_investment_advice
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, ensure_ascii=False, indent=2) # Removed default=str
            self.logger.info(f"ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜æˆåŠŸ: {filename}")
            return filename
        except TypeError as te: # Catch TypeError specifically if dump fails
            self.logger.error(f"JSONã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚¨ãƒ©ãƒ¼ ({filename}): {te}. ãƒ‡ãƒ¼ã‚¿å‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚", exc_info=True)
            # Attempt to save with a more aggressive cleaner if TypeError occurs
            try:
                self.logger.warning("ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚¨ãƒ©ãƒ¼ã®ãŸã‚ã€ã‚ˆã‚Šç©æ¥µçš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã§å†è©¦è¡Œã—ã¾ã™...")
                cleaned_report_data_aggressive = clean_data_for_json(report_data)
                with open(filename, 'w', encoding='utf-8') as f:
                     json.dump(cleaned_report_data_aggressive, f, ensure_ascii=False, indent=2)
                self.logger.info(f"ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜æˆåŠŸ (ç©æ¥µçš„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¾Œ): {filename}")
                return filename
            except Exception as e_aggressive:
                self.logger.error(f"ç©æ¥µçš„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¾Œã‚‚ä¿å­˜ã‚¨ãƒ©ãƒ¼ ({filename}): {e_aggressive}", exc_info=True)
                return None

        except Exception as e:
            self.logger.error(f"ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ä¸€èˆ¬ã‚¨ãƒ©ãƒ¼ ({filename}): {e}", exc_info=True)
            return None


    def validate_system(self) -> Dict[str, Any]:
        validation = {
            "market_data_loaded": self.sp500_df is not None and not self.sp500_df.empty,
            "ai_models_loaded": bool(self.trained_models_results), # Check if dict is not empty
            "profile_valid": self.current_profile in self.PROFILES,
            "config_accessible": self._get_current_config() is not None,
            "ai_predictions_functional": False, # Default to False
            "vix_value_retrieved": False,
            "technical_indicators_calculated": False,
        }
        
        try:
            preds, errors = self._get_ai_predictions_summary()
            # Check if predictions dict has expected keys and non-default values
            if preds and "long_term" in preds and "trend_pct" in preds["long_term"]:
                 # Could add a check for non-zero or non-default trend_pct
                 validation["ai_predictions_functional"] = True
            if errors: # e.g. check if errors dict is populated as expected
                pass # Add specific checks for errors if needed
        except Exception as e:
            self.logger.warning(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼ä¸­ã€AIäºˆæ¸¬ã‚µãƒãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
        
        try:
            vix = self._get_vix_value()
            if vix is not None and isinstance(vix, float): # Check if a float value was returned
                validation["vix_value_retrieved"] = True
        except Exception as e:
            self.logger.warning(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼ä¸­ã€VIXå€¤å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")

        try:
            tech_signals = self._get_technical_signals_summary()
            if tech_signals and "error" not in tech_signals : # Check if dict is not empty and no error
                validation["technical_indicators_calculated"] = True
        except Exception as e:
            self.logger.warning(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼ä¸­ã€ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")

        validation["overall_system_health"] = all(
            v for k, v in validation.items() if k != "overall_system_health" # Exclude self-reference
        )
        self.logger.info(f"ã‚·ã‚¹ãƒ†ãƒ æ¤œè¨¼çµæœ: {validation}")
        return validation
